{"pages":[{"title":"大前端技术体系","text":"核心 网页行为：JavaScript ✅ 编码规范 thanks to airbnb 😂 ⬜ JavaScript 简介 ⬜ 变量提升(Variable Hoisting)、事件冒泡(Event Bubbling)、严格模式(Strict) ⬜ this ⬜ 闭包(Closure) ⬜ 原型(Prototype)与原型链(Prototype Chain) ⬜ JSON(JavaScript Object Notation) ⬜ 作用域(Scope)与作用域链(Scope Chain) ⬜ AJAX(Asynchronous Javascript And XML) ⬜ 跨域(Cross Domain) ⬜ 模块化(Module) ⬜ 事件循环(Event Loop) ⬜ 正则表达式(Regular expressions) ⬜ Web API(CustomEvent、WebSockets、Web Workers.etc) ES5-ES6+ ✅ JavaScript 新特性 吴俊 图形 ⬜ Canvas ⬜ WebGL ⬜ SVG Web Component ⬜ Shadow DOM TypeScript ✅ 编码规范 刘莹鑫 ⬜ 类型(Type) ⬜ 接口、类、命名空间、模块 ⬜ 装饰器 ⬜ 声明文件 网页样式：CSS ✅ CSS 编码规范 刘燕 ⬜ CSS 实战 ⬜ BEM ⬜ 响应式和媒体查询 ⬜ Sass 编码规范 刘燕 网页结构：HTML ✅ HTML 编码规范 刘燕 ⬜ HTML 简介 ⬜ HTML5 特性 概念 基本 ✅ 前端开发必须掌握的基本概念 段美霞 ⬜ 值 🆚 引用类型，栈 🆚 堆 ⬜ 形参 🆚 实参，转译 🆚 编译 ⬜ BOM 🆚 DOM ⬜ 对称加密 🆚 非对称加密 ⬜ 逻辑像素 🆚 物理像素 rem 🆚 em pt 🆚 dp ⬜ 标准化组织 进阶 ⬜ 字符编码(Character Encodings) ⬜ SOAP 和 RESTful 能做比较吗？ ⬜ 开源协议 ⬜ 命令式 🆚 声明式 开发周边 ⬜ 命令行 ⬜ JSDoc ⬜ Markdown ⬜ GitHub ⬜ 蓝湖 ⬜ Fiddler ⬜ Chrome DevTools ⬜ PostWoman ✅ RAP2 入门 刘莹鑫 协议相关 ⬜ OSI 模型 ⬜ DNS ✅ HTTP 请求方法的异同 天下布武 ⬜ HTTPS ⬜ 端口 ⬜ URI 🆚 UDP 浏览器 ⬜ 浏览器历史 ⬜ 主流浏览器对比 ⬜ 浏览器工作原理 JS 框架 Vue.js ✅ Vue.js2 最佳实践 天下布武 ✅ Vue 组件开发及 NPM 发布（TS 版） 天下布武 ⬜ SSR Angular ⬜ Angular 组件开发及 NPM 发布 ReactUI 框架 ⬜ Element ⬜ Ionic 库 ⬜ ECharts ⬜ D3 ⬜ three.js ⬜ RxJS 跨平台 ✅ PWA–下一代的 web 应用模型 曹芯萍 ⬜ Cordova ⬜ Electron ⬜ Flutter？ ⬜ Service Worker 服务器&amp;操作系统&amp;中间件 ⬜ nginx 使用 ⬜ Tomcat ⬜ IIS 添加 HTTPS ⬜ Redis ⬜ RabbitMQ ⬜ CentOS Node.js ⬜ NPM ⬜ Nest.js ⬜ mongoose ⬜ socket.io 数据库 ⬜ MongoDB ⬜ PostgreSQL 编辑器&amp;IDE ⬜ VS Code ⬜ WebStrom ⬜ Xcode ⬜ Android Studio 持续集成&amp;交付&amp;部署 ⬜ SVN ⬜ Git ⬜ 常用构建、静态分析工具及配置 ⬜ Jenkins ⬜ Docker 监控 ⬜ Sentry ⬜ New Relic 数据结构&amp;算法 ⬜ 时间复杂度、空间复杂度 设计思想&amp;模式 性能 安全 ⬜ JWT 管理 ⬜ 招聘 ⬜ 团队管理 ⬜ 项目管理 ⬜ PPT ⬜ Word ⬜ 设计说明书 其它 ⬜ WebRTC ⬜ WebAssembly ⬜ Tensorflow.js ⬜ GraphQL ⬜ Serverless 大前端技术体系一张图","link":"/fe/index.html"},{"title":"gis","text":"概念 ⬜ 地理坐标系 ⬜ 插值 ⬜ WebGL ⬜ 空间坐标系 ⬜ 正交投影 🆚 透视投影 ⬜ 上帝说有光，于是便有了光 ⬜ 纹理 ⬜ 旋转、跳跃，我闭着眼 ⬜ 粒子系统 ⬜ 着色器 桌面软件ArcMapQGIS服务器ArcGIS ServerGeoServer数据库PostGIS工具库ArcpyGDAL2D Map库ArcGIS API for JavaScriptTurf3D Map库three.jsCesium","link":"/gis/index.html"},{"title":"关于我们","text":"思路大前端团队于2018年成立，分布北京、成都、深圳、西安四地，是由UI设计师、前端开发工程师、GIS开发工程师共同组成的集设计与开发为一体的综合性团队。我们致力于产品的用户体验设计，利用各种可视化技术手段进行信息展现，为各业务线提供可视化解决方案，增强产品的核心竞争力。 愿景成为一个学习型且有影响力的团队，同时为业内一流的可视化解决方案提供者 使命利用技术提升产品的核心竞争力 文化开心、乐观、自驱、互助、专业、创新 职责参与产品设计讨论，结合用户体验为公司新产品与新功能提供创意及设计方案，跟踪设计效果，并把控产品最终界面实现效果结合项目的整体计划和安排，协助其他开发人员解决项目开发过程中的技术难题参与前端工程构建系统的研发，包括开发规范、自动化工具、框架开发、可视化搭建、数据埋点、持续集成、应用监控、性能优化等实现界面和交互的开发需求，确保不同平台、设备上具有优秀的用户体验负责数据可视化前沿技术的研究，可视化平台整体架构设计和研发 加入我们对用户来说，界面就是一切。想做一个掌控一切的人吗？加入我们吧！ 可加微信发送简历：zapzqc","link":"/about/index.html"}],"posts":[{"title":"HTTP请求方法的异同","text":"HTTP（HyperText Transfer Protocol，超文本传输协议）中定义的请求方法共八种（GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE，参看RFC7231）。工作中我们最常接触到的是其中的GET、POST、PUT和DELETE。网上有很多针对这四种方法的说明和比较，但内容都不尽如人意。为了能让大家更清晰地了解这些方法，在实际工作中灵活运用，我将从定义和实现两个方面详细地阐述一下它们的异同。 首先，看一些基本概念。超文本传输协议是网络七层结构中应用层的协议。我们看到“超文本”一般会联想到另一个词：HTML(HyperText Mark-up Language，超文本标记语言)。那什么是“超文本”？“超文本”是1965年美国人Ted Nelson创造的，简单的说就是包含有其他文本链接的文本 (Hypertext is text which contains links to other texts)，通过这些链接可以访问指向的文本。HTML就是用来创建超文本(如Web页面)的。最初设计HTTP的目的是为了能够在客户端和服务器端之间传输超文本文档 (HTML)**。不过随着时代的发展，“超文本”已经从最初的纯文本扩展成为包括文本、图像、音频、视频等在内的多媒体。现今，把HTTP称为超媒体传输协议可能更为合适些**。 针对HTTP，有文档明确定义的版本有0.9（1991）、1.0（1996）、1.1（1997）和2（2015）。目前使用最广泛的是1.1，该规范由IETF（Internet Engineering Task Force，互联网工程任务组）中的HTTP Working Group（HTTP工作组）于2014年更新，定义的内容在RFC7230–RFC7235六个文档中。 接下来，开始正式的对比： 定义上RFC文档定义了三种方法属性：安全、幂等、可缓存。 安全 如果请求方法的语义是只读的(如GET、HEAD、OPTIONS、TRACE )，那么该方法就是安全的。也就是说客户端不会请求和期望改变服务器上目标资源的任何状态。 幂等 如果使用该方法对服务器发送多次相同请求和一次请求的效果是一样的，那么该方法就被认为是幂等的。PUT, DELETE及上面提到的安全方法都是幂等的。 可缓存 对于请求方法的响应被允许存储以备将来重用，那么该方法就可以定义为“可缓存”。一般来说，不依赖于当前响应的安全方法被定义为可缓存的。规范将GET，HEAD和POST定义为可缓存，尽管绝大多数缓存实现只支持GET和HEAD。 属性 GET POST PUT DELETE 安全 是 否 否 否 幂等 是 否 是 是 可缓存 是 是 否 否 语义 检索信息（查） 创建或附加资源（增、改） 创建或替换资源（增、改） 删除资源（删） ⚠️ 以上的“是”，指的是定义中有明确要求的。“否”指的是没有明确要求，可做可不做的。 稍微解释下： 安全：使用GET方法，不能修改服务器上的数据，而其它方法是可以的。 幂等：同样是添加资源，使用PUT只能添加一条数据，无论执行多少次。而使用POST可以是执行一次就添加一条新数据。 补充： 所有通用的服务器必须支持GET和HEAD方法，其他方法是可选的。这和大部分的实现还算是比较吻合，因为一般的服务器是做网站用途的，在地址栏中访问对应的URL地址、图片引入、JS文件引入、CSS文件引入等都是发送的GET请求。 无论是GET还是POST都没有限制请求参数的长度和位置（URL后还是消息体message body里）。 实现上 GET能被缓存，POST很少能被缓存 。 GET 和 POST 请求参数的位置不同，GET 请求的参数放在 URL 中（以?分割URL和传输数据，参数之间以&amp;相连，如：login?name=zqc&amp;password=zqc。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64编码，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII），而 POST 请求的参数放在消息体中。 由于以上2的缘故，再加上有些服务器会记录和打印GET请求的地址，因此，POST比GET相对安全一些。但是使用抓包工具的话，只要不加密，参数都能被轻而易举地获取。 华为手机浏览器不支持PUT方法，因此有些公司会规定添加和修改都使用POST。 GET和POST请求参数的大小主要是由浏览器和Web服务器决定。以下是利用node.js做服务端进行的一系列测试（感谢 橘子君）： 浏览器 请求类型 GET(Bytes) POST(Bytes) IE11 地址栏 2047 -- ajax 81593 102400 IE11 地址栏 2047 -- ajax Edge 地址栏 2083 -- ajax 81488 102400 Chrome 地址栏只粘贴 81550 -- 粘贴加输入 如果超32791，则为：32791+一次性新输入个数 -- ajax 有可能是服务器端限制 81459 102400 python ajax 81825 102400 也就是说除了在地址栏中输入URL发送GET请求有明显的限制，而直接通过代码发送请求，Get(80K左右)和Post(100K)发送的数据大小相差不多。 误区 一般认为HTTP请求方法与CRUD(Create, Read, Update, Delete)操作的对应关系如下：而实际上，除了GET和DELETE可以这样对应，POST和PUT都可以作为增加或修改操作。 CRUD HTTP 增加 POST 查询 GET 更新 PUT 删除 DELETE GET请求能够被保存在浏览器的浏览历史里面 不准确！只有是在浏览器地址栏内输入的URL地址才可以在浏览器历史中查看。 GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同，POST请求无长度限制 不准确！上方已经写出了结论：除了在地址栏中输入URL发送GET请求有明显的限制，而直接通过代码发送请求，Get(80K左右)和Post(100K)发送的数据大小相差不多。 最后，再看下HTTP状态码，简单易懂：","link":"/2020/04/26/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C/"},{"title":"博客使用指南","text":"我们现在使用的博客框架是Hexo，感兴趣的同学可以去了解下。 下载源码从GitHub的仓库中下载博客工具源码到自己机器上 1git clone https://github.com/THS-FE/blog.git 安装依赖进入项目所在文件夹，执行 12npm install -g hexo-clinpm install 新建帖子1hexo new post '博客的名称' 需要用到图片等资源都放进新生成的文件夹中，图片尽量是JPG格式。使用以下语句来引入图片 1{% asset_img 你的图片名称.jpg %} 删除帖子直接在source_posts文件夹下删除对应的md文件和文件夹，再运行命令 12hexo cleanhexo g 运行博客1hexo s 执行成功后，在浏览器中输入 http://localhost:4000/ 发布博客前提是你有这个仓库的修改权限。修改提交说明 运行命令 12hexo ghexo deploy 第一次会要求输入你Github的用户名和密码。 如果部署以后发现 https://ths-fe.github.io/ 博客没有更新，需要手动删除项目中的.deploy_git文件夹，重新运行命令 12hexo cleanhexo g -d","link":"/2020/04/24/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"Vue.js2最佳实践(持续更新至Vue.js3出来😁)","text":"写在开头 文档较长，可按需耐心反复阅读。其中带（官）的是直接引用了Vue官方的风格指南。针对Vue性能优化相关内容，单独在内容后进行了标注，可通过搜索“性能优化”四个字查找。 Vue.js2模板工程说明目的封装常用功能和配置，规范代码编写，保证输出的一致性，方便前端人员在此基础上快速开发新项目的业务模块。 下载模板项目（Boilerplate）分为JavaScript和TypeScript两个版本。 JS： git clone https://github.com/THS-FE/vue2-starter-js.git TS： git clone https://github.com/THS-FE/vue2-starter-ts.git 目录结构该目录结构适合中大型项目，如果是小型项目，可对目录或模块进行适当删减（尤其是后面有可选标识的）。 JavaScript版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要的工作目录 ├── assets // 静态资源 会经过webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── error // error（通用出错页面）模块 └── ... // 使用到的图片 ├── module-a // 用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出，最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 不同项目中的通用组件 ├── module-a // 用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.js // Element按需加载 ├── index.js // 插件的入口文件，组装各插件并导出 └── ... // 自定义插件 ├── router // 路由（统一使用懒加载） ├── index.js // 路由的入口文件，组装各路由并导出 └── ... ├── services // 接口请求 ├── config.js // 常量 ├── index.js // 服务调用的入口文件，组装各模块请求方法并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 命名尽量和views中的模块对应上 ├── actions.js // 根级别的 action ├── getters.js // 根级别的 getter ├── index.js // 状态管理的入口文件，组装各模块并导出 ├── mutation-types.js // mutation事件类型定义 └── mutations.js // 根级别的 mutation ├── utils // 工具类 ├── config.js // 常量 ├── common.js // 常用功能（通用的） ├── request.js // HTTP请求封装 ├── validator.js // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常页面 ├── not-found.vue // 404页面 └── unauthorized.vue // 403页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 └── main.js // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范，如：缩进├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本└── vue.config.js // webpack打包配置 在创建该项目时，没有添加PWA、单元测试和端到端测试。原因：PWA并没有普及，没多少人会使用；各类测试对于需求经常变化的项目来说就是个累赘，测试用例还没有写完，需求变了… 对项目相关工具配置项不了解的，可参看 《从零开始搭建前端项目开发环境》 TypeScript版因Vue3.0取消了基于类的组件（class based component），使用functional based component+hooks(也就是Composition API)，为了降低学习成本，在使用脚手架创建项目时，没有启用vue-class-component。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录 ├── assets // 静态资源 会被webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── exception // exception（通用异常页面）模块使用到的图片 └── ... ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 通用组件 ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.ts // Element按需加载 ├── index.ts // 组装各插件并导出 └── ... ├── router // 路由（统一使用懒加载） ├── index.ts // 组装各路由并导出 └── ... ├── services // 接口请求 ├── config.ts // 常量 ├── index.ts // 组装各请求并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 尽量和views中的模块对应上 ├── actions.ts // 根级别的 action ├── getters.js // 根级别的 getter ├── index.ts // 组装模块并导出 ├── mutation-types.ts // mutation事件类型定义 └── mutations.ts // 根级别的 mutation ├── utils // 工具类 ├── config.ts // 常量 ├── common.ts // 常用功能（提供通用的） ├── request.ts // HTTP请求 ├── validator.ts // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常展示页面 ├── NotFound.vue // 404页面 └── Unauthorized.vue // 401页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等） ├── shims-tsx.d.ts // 允许使用tsx的文件，用于编写jsx风格的ts代码 └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── postcss.config.js// postcss配置├── tsconfig.json // TypeScript配置文件└── vue.config.js // webpack打包配置 配置变更以下内容均已在模板项目里添加，这里只是做个说明。 新增依赖Normalize.css 6.2k为默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 安装： npm i normalize.css -S 已在main.js文件中引入： import 'normalize.css'; moment 239.1kDay.js 6.3k是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样，用于解析、检验、操作、以及显示日期。 安装： npm i dayjs -S 可在任何需要的文件中引入： 1234import dayjs from 'dayjs';import 'dayjs/locale/zh-cn';dayjs.locale('zh-cn'); // 使用中文 Element 637.7k一套为开发者、设计师和产品经理准备的基于 Vue2.0 的桌面端组件库。 安装： npm i element-ui -S 已在plugins/index.js文件中引入： 1234import ElementUI from 'element-ui';import '@/assets/styles/element-variables.scss';Vue.use(ElementUI); 项目中已改成按需加载。 axios 12.9k是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 安装： npm i axios -S 已在utils/request.js文件中引入： import axios from 'axios'; vue-event-proxy 1.79kb让Vue.js支持全局事件的库。 通过增加前缀实现全局事件，能在不同组件间进行数据通信 组件销毁自动移除注册的事件 安装： npm i vue-event-proxy -S 已在plugins/index.js文件中引入： 123import EventBus from 'vue-event-proxy';Vue.use(EventBus); TS版需要同时在shims-vue.d.ts文件中添加模块申明： declare module 'vue-event-proxy' 在非父子组件间使用（相当于事件总线）： 12345// 发布this.$emit('global:你的事件名字');// 监听this.$on('global:你的事件名字', () =&gt; {}); 如不加 global: 前缀，则和平时使用的方式一致。 新增功能request定义拦截器对HTTP请求配置做统一处理。 已写在utils/request.js文件中，需按实际项目需要进行修改： 1234567891011121314151617181920212223242526272829303132333435363738import axios from 'axios';const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url// withCredentials: true, // 如跨域请求时要带上cookie,则设置为true timeout: 5000, // 请求超时时长});service.interceptors.request.use( (config) =&gt; { // 按需添加内容 // eslint-disable-next-line no-empty if (config.method === 'post') { } return config; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);service.interceptors.response.use( (response) =&gt; { // 如果返回的状态不是200 就报错 按需修改 if (response.status &amp;&amp; response.status !== 200) { return Promise.reject(new Error('Error')); } return response; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);export default service; 如果使用同一个服务地址，那么还需要在vue.config.js中要修改： // 设置HTTP请求的base url，需修改 12// 设置HTTP请求的base url，需修改process.env.VUE_APP_BASE_API = isProd() ? '这里要修改成实际的地址' : ''; 导航守卫通过跳转或取消的方式守卫导航。 已写在router/index.js文件中，需按实际项目需要进行修改： 1234567891011121314router.beforeEach((to, from, next) =&gt; { // 如果登录的时候设置过; if (localStorage.getItem('token') != null) { next(); } else { // 如果没有设置这个值为空,说明没有登录，导向登录页 // eslint-disable-next-line no-lonely-if if (to.name === 'login') { next(); } else { next({ path: '/login' }); } }}); 路由拆分按模块拆分成不同的路由文件，方便多人协作同步开发，互不影响。 可在router/index.js 文件中添加： 12345678910111213141516171819202122import homeRoutes from './home'; // 引入首页模块的路由// routes 需要定义类型let routes: RouteConfig[] = [{ path: '/', redirect: '/login',},{ path: '/login', name: 'login', component: Login,},...];routes = [...routes, ...homeRoutes]; // 合并它模块的路由const router = new Router({ mode: 'history', base: process.env.BASE_URL, routes,}); store拆分如果项目非常大状态就会有很多，如不进行分类处理，所有的状态和对状态的处理都放一个文件里面，代码会很臃肿，不利于后期的维护。 在store/index.js 文件中： 123456789101112131415161718import mutations from './mutations';import actions from './actions';import getters from './getters';import user from './modules/user';const state = {};export default new Vuex.Store({ state, getters, actions, mutations, modules: { user, },}); Vue Composition API方便以后平滑过渡到 Vue.js3.0。 安装： npm i @vue/composition-api -S 已在plugins/index.js文件中引入： 123import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionApi) 主题切换待添加… 配置新增vue.config.js为了不改变默认配置，在 configureWebpack 中通过 Object.assign 的方式合并配置，这种方式只会对配置进行新增、修改，而不会过多地改变默认配置。 去除console1234// 去除 consoleObject.assign(config.optimization.minimizer[0].options.terserOptions.compress, { drop_console: true,}); 分离第三方库123456789// 单独将 elementUI 拆包Object.assign(config.optimization.splitChunks.cacheGroups, { elementUI: { name: 'chunk-elementUI', priority: 20, // 权重要大于 vendors 和 app 不然会被打包进 vendors 或者 app test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/, chunks: 'all', },}); Element 按需加载 (性能优化1)安装： npm install babel-plugin-component -D 修改babel.config.js： 123456789101112131415module.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], // element按需加载 plugins: [ [ 'component', { libraryName: 'element-ui', styleLibraryName: 'theme-chalk', }, ], ],}; 安装运行在项目所在文件夹下运行命令行安装依赖： npm install 如果NPM下载慢的话，可使用以下命令： npm install --registry=https://registry.npm.taobao.org 项目启动： npm run serve 项目打包： npm run build 命名组件尽量将组件放在对应目录所属模块的文件夹之下，若只有一个文件的则直接放在components或views目录下，如：login，home。 组件名尽量为名词，开头的单词就是所属模块的名字。 （官）使用两个或以上单词根组件 App 以及 &lt;transition&gt;、&lt;component&gt; 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 Bad 123Vue.component('todo', { // ...}) 1234export default { name: 'Todo', // ...} Good 123Vue.component('todo-item', { // ...}) 1234export default { name: 'TodoItem', // ...} 常用的结尾单词有 123456789***-detail.vue***-edit.vue***-list.vue***-info.vue***-report.vue （官）使用PascalCase或kebab-case命名组件文件单词大写开头对于代码编辑器的自动补全最为友好。 Bad 12components/|- mycomponent.vue 12components/|- myComponent.vue Good 12components/|- my-component.vue （官）JS/JSX 中的组件名应该始终使用 PascalCase 进行命名在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。 然而，对于只通过 Vue.component 定义全局组件的应用来说，推荐 kebab-case 作为替代。原因是： 全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。 这些应用往往包含许多 DOM 内的模板，这种情况下是必须使用 kebab-case 的。 Bad 123Vue.component('myComponent', { // ...}) 1import myComponent from './MyComponent.vue' 1234export default { name: 'myComponent', // ...} 1234export default { name: 'my-component', // ...} Good 123Vue.component('MyComponent', { // ...}) 123Vue.component('my-component', { // ...}) 1import MyComponent from './MyComponent.vue' 1234export default { name: 'MyComponent', // ...} （官）和父组件紧密耦合的子组件应该以父组件名作为前缀命名可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如： 123456components/|- TodoList/ |- Item/ |- index.vue |- Button.vue |- index.vue 或： 123456components/|- TodoList/ |- Item/ |- Button.vue |- Item.vue|- TodoList.vue 但是这种方式并不推荐，因为这会导致： 许多文件的名字相同，使得在编辑器中快速切换文件变得困难。 过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。 Bad 1234components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue 123components/|- SearchSidebar.vue|- NavigationForSearchSidebar.vue Good 1234components/|- TodoList.vue|- TodoListItem.vue|- TodoListItemButton.vue 123components/|- SearchSidebar.vue|- SearchSidebarNavigation.vue （官）以高级别的(通常是一般化描述的) 单词开头，以描述性的修饰词结尾比如对于一个带搜索表单的应用来说，它可能包含这样的组件： 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue 很难看出来哪些组件是针对搜索的。现根据规则给组件重新命名： 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputExcludeGlob.vue|- SearchInputQuery.vue|- SettingsCheckboxLaunchOnStartup.vue|- SettingsCheckboxTerms.vue 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。 若换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为： 在多级目录间找来找去，要比在单个 components 目录下滚动查找花费更多的精力。 存在组件重名 (比如存在多个 ButtonDelete 组件) 的时候在编辑器里更难快速定位。 让重构变得更难，为一个移动了的组件更新相关引用时，查找/替换通常并不高效。 Bad 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue Good 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputQuery.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxTerms.vue|- SettingsCheckboxLaunchOnStartup.vue （官）使用完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。 Bad 123components/|- SdSettings.vue|- UProfOpts.vue Good 123components/|- StudentDashboardSettings.vue|- UserProfileOptions.vue （官）基础组件(也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base 当在编辑器中以字母顺序排序时，应用的基础组件会全部列在一起，这样更容易识别。 因为组件名应该始终是多个单词，所以这样做可以避免在包裹简单组件时随意选择前缀 (比如 MyButton、VueButton)。 因为这些组件会被频繁使用，所以可能想把它们放到全局而不是在各处分别导入它们。 Bad 1234components/|- MyButton.vue|- VueTable.vue|- Icon.vue Good 1234components/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue （官）单个活跃实例的组件应该以The前缀命名，以示其唯一性这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为应用定制的，而不是它们在应用中的上下文。如果发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。 Bad 123components/|- Heading.vue|- MySidebar.vue Good 123components/|- TheHeading.vue|- TheSidebar.vue Prop（官）应该始终使用camelCase，而在模板和 JSX 中应该始终使用 kebab-case我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 Bad 123props: { 'greeting-text': String} 1&lt;WelcomeMessage greetingText=\"hi\"/&gt; Good 123props: { greetingText: String} 1&lt;WelcomeMessage greeting-text=\"hi\"/&gt; method要是动宾短语Bad go、nextPage、show、open、login Good jumpPage、openCarInfoDialog 尽量使用常用单词开头： set、get、open、close、jump 使用camelCase进行命名Bad get_list_data、getlistData Good getListData 事件（官）使用kebab-case进行命名无论是camelCase 或 PascalCase的命名，都能被监听到，但 DOM 模板中使用会感觉怪怪的。 以动词或是名词结尾如：upload-success、upload-error 、 dropzone-upload-success、dropzone-upload-error。 文件夹尽量是小写的单个名词有复数结构时，要采用复数命名法。例：scripts, styles, images。 如不是单个，则使用 kebab-case进行命名使用kebab-case命名的文件夹比camelCase命名的文件夹看起来更清晰，可参考node_modules文件夹里的内容。 Bad 123errorPageErrorPage Good 1error-page 文件*.js文件命名规范统一使用kebab-case风格 *.ts文件命名规范统一使用kebab-case风格 *.scss文件命名规范统一使用kebab-case命名风格 其它文件命名规范统一使用kebab-case命名风格 一般约束（官）顶级App组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的这条规则只和单文件组件有关。不一定要使用 scoped 特性。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然也可以使用其它的库或约定。 Bad 123456789&lt;template&gt; &lt;button class=\"btn btn-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;.btn-close { background-color: red;}&lt;/style&gt; Good 123456789101112131415&lt;template&gt; &lt;button class=\"button button-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button { border: none; border-radius: 2px;}.button-close { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button :class=\"[$style.button, $style.buttonClose]\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 CSS Modules --&gt;&lt;style module&gt;.button { border: none; border-radius: 2px;}.buttonClose { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button class=\"c-Button c-Button--close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;.c-Button { border: none; border-radius: 2px;}.c-Button--close { background-color: red;}&lt;/style&gt; （官）始终为插件、混入等不考虑作为对外公共API的自定义私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突Vue 使用 _前缀来定义其自身的私有属性，所以使用相同的前缀 (比如_update) 有覆写实例属性的风险。即便检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。 对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。 不过，推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。。 Bad 12345678var myGreatMixin = { // ... methods: { update: function () { // ... } }} 12345678var myGreatMixin = { // ... methods: { _update: function () { // ... } }} 12345678var myGreatMixin = { // ... methods: { $update: function () { // ... } }} Good 12345678var myGreatMixin = { // ... methods: { $_myGreatMixin_update: function () { // ... } }} 12345678910111213141516// 甚至更好！var myGreatMixin = { // ... methods: { publicMethod() { // ... myPrivateFunction() } }}function myPrivateFunction() { // ...}export default myGreatMixin （官）在单文件组件、字符串模板和JSX中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有&quot;本页有意留白&quot;标签的白纸。而且没有了额外的闭合标签，代码也更简洁。 不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的&quot;空&quot;元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。 Bad 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component/&gt; Good 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent/&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component&gt;&lt;/my-component&gt; （官）组件的data必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。若希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。 Bad 12345Vue.component('some-comp', { data: { foo: 'bar' }}) 12345export default { data: { foo: 'bar' }} Good 1234567Vue.component('some-comp', { data: function () { return { foo: 'bar' } }}) 12345678910// In a .vue file 尽量使用简写export default { data () { // 可以在这里写很多的前置数据操作 ... return { foo: 'bar' } }} 1234567// 在一个 Vue 的根实例上直接使用对象是可以的，// 因为只存在一个这样的实例。new Vue({ data: { foo: 'bar' }}) （官）Prop定义要详细：类型、必填、验证细致的 prop定义有两个好处： 它们写明了组件的 API，所以很容易看懂组件的用法； 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。 Bad 123Vue.component({ props: ['status']}) Good 123456789Vue.component({ props: { status: { type: String, required: true, validator: (value) =&gt; ['syncing', 'synced', 'error'].includes(value); } }}) （官）尽量使用指令缩写，而且要么都用要么都不用用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot。 Bad 1234&lt;input v-bind:value=\"newTodoText\" :placeholder=\"newTodoInstructions\"&gt; 1234&lt;input v-on:input=\"onInput\" @focus=\"onFocus\"&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; Good 1234&lt;input :value=\"newTodoText\" :placeholder=\"newTodoInstructions\"&gt; 1234&lt;input v-bind:value=\"newTodoText\" v-bind:placeholder=\"newTodoInstructions\"&gt; 1234&lt;input @input=\"onInput\" @focus=\"onFocus\"&gt; 1234&lt;input v-on:input=\"onInput\" v-on:focus=\"onFocus\"&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 1234567&lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; （官）应该优先通过Vuex管理全局状态，而不是通过 this.$root 或一个全局事件总线通过 this.$root和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。 Bad 1234567891011121314151617// main.jsnew Vue({ data: { todos: [] }, created: function () { this.$on('remove-todo', this.removeTodo) }, methods: { removeTodo: function (todo) { var todoIdToRemove = todo.id this.todos = this.todos.filter(function (todo) { return todo.id !== todoIdToRemove }) } }}) Good 12345678910111213141516// store/modules/todos.jsexport default { state: { list: [] }, mutations: { REMOVE_TODO (state, todoId) { state.list = state.list.filter(todo =&gt; todo.id !== todoId) } }, actions: { removeTodo ({ commit, state }, todo) { commit('REMOVE_TODO', todo.id) } }} 1234567891011121314151617181920212223&lt;!-- TodoItem.vue --&gt;&lt;template&gt; &lt;span&gt; {{ todo.text }} &lt;button @click=\"removeTodo(todo)\"&gt; X &lt;/button&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from 'vuex'export default { props: { todo: { type: Object, required: true } }, methods: mapActions(['removeTodo'])}&lt;/script&gt; （官）简单逻辑可在模板中使用表达式，中等逻辑操作使用computed ，复杂或需调用异步方法时使用watch模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id=\"example\"&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量message的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"{{ message }}\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"{{ reversedMessage }}\"&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } }}) 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过watch选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 123456789101112131415161718192021222324252627282930313233&lt;script&gt;var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...'this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，// 请参考：https://lodash.com/docs#debouncethis.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)'return } this.answer = 'Thinking...'var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } }})&lt;/script&gt; 生命周期函数调用规则 编程思想（官）组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法复杂表达式会让模板变得不那么声明式。应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。Bad 12345{{ fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ')}} Good 12&lt;!-- 在模板中 --&gt;{{ normalizedFullName }} 12345678// 复杂表达式已经移入一个计算属性computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} （官）应该优先通过prop和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让组件更易于理解。访问组件之外的上下文违反了基于模块开发的第一原则。因此应该尽量避免使用 this.$parent。 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 在有些情况下，可能需要对一个 prop 进行&quot;双向绑定&quot;。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源，推荐以 update:myPropName 的模式触发事件取而代之。在子组件中通过.sync/emit模式来改变父组件传入的Props的值。 Bad 1234567891011121314151617181920212223Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo () { var vm = this; vm.$parent.todos = vm.$parent.todos.filter(function (todo) { return todo.id !== vm.todo.id }) } }, template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=\"removeTodo\"&gt; X &lt;/button&gt; &lt;/span&gt; `}) Good 123456789101112131415161718192021222324// parent template&lt;todo-item :todo.sync=\"todoObj\"&gt;// childVue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo: (newFoo) =&gt; { this.$emit('update:todo', newTodoObj); } }， template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=\"removeTodo\"&gt; X &lt;/button&gt; &lt;/span&gt; `}) 谨慎使用 this.$refsVue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 Good 12345678&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max=\"max\" :min=\"min\" @current-value=\"currentValue\" :step=\"1\"&gt;&lt;/range&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref=\"basicModal\"&gt; &lt;h4&gt;Basic Modal&lt;/h4&gt; &lt;button class=\"primary\" @click=\"$refs.basicModal.hide()\" &gt;Close &lt;/button&gt;&lt;/modal&gt;&lt;button @click=\"$refs.basicModal.open()\" &gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt; &lt;div v-show=\"active\"&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { // ... data() { return { active: false, }; }, methods: { open() { this.active = true; }, hide() { this.active = false; }, }, // ... };&lt;/script&gt; 按照一定的结构顺序来组织组件 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM。 使用单文件 .vue 文件格式来组件代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class=\"Ranger__Wrapper\"&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { // 不要忘记 name 属性 name: 'RangeSlider', // 使用组件 mixins 共享通用功能 mixins: [], // 使用其它组件 components: {}, // 组成新的组件 extends: {}, // 指令 directives: {}, // 组件属性、变量 props: { bar: {}, // 按字母顺序 foo: {}, fooBar: {}, }, // 变量 data() { return {} }, // 方法 computed: {}, watch: {}, methods: {}, // 生命周期函数（按顺序） ... beforeCreate() {}, created () {}, mounted() {} ... };&lt;/script&gt;&lt;style scoped&gt; .Ranger__Wrapper { &lt;!-- ... --&gt; }&lt;/style&gt; 接口调用流程未使用状态管理时： 在services文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在单文件组件中调用上述方法。 使用状态管理时： 在services文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在store的actions中调用上述方法，commit到mutation，mutation改变state的值。 在单文件组件中调用actions中的方法。 每个分类都只有一个入口（如：router、store、plugins等分类下）即每个文件夹下都会有一个index.js/ts, 目的是对外隔离，当引入该分类下的文件时，不用按每个JS模块路径引入，否则调整单个模块位置需要修改依赖它的所有模块。 每个分类内部模块互相引用时，使用相对路径; 分类之间模块引用时，使用绝对路径相对路径目的是对外隔离，不和分类外的路径产生关系，同时方便分类复用。如 plugins 文件夹下的 index 文件。 12// Elementimport './element'; 绝对路径目的是从语义上区分模块是否是同一分类，分类路径发生改变时一次性全局替换。如在 main.js 中引入 plugins。 1import '@/plugins'; // 按需引入插件 vue组件、assets等其它各模块的引用路径，类似如下，用&quot;@&quot;直接引用src目录下的，而不是使用相对路径。 12import AjaxTree from '@/components/tree/ajax-tree'import VmTable from '@/components/table/vm-table' css的文件引用路径如下，用&quot;~@&quot;替换之前的&quot;../../&quot;： 1234&lt;style lang=\"scss\"&gt;@import '~@/assets/styles/common.scss';@import '~@/assets/styles/table.scss';&lt;/style&gt; 组件封装组件分为dumb component（普通组件，一般是components里的一个单文件组件） 和 smart component（容器组件，一般是views里的一个单文件组件）两种。 普通组件尽量只通过 props 接收容器组件传来的数据，向父组件派发消息，而不做其它任何主动调取数据等工作。 性能优化（官）总是用key配合 v-for (性能优化2)在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 同时，Key不要为index，尽量是一个唯一值，因为数据发生变化时，index可能不变。 Bad 12345&lt;ul&gt; &lt;li v-for=\"todo in todos\"&gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; Good 12345678&lt;ul&gt; &lt;li v-for=\"todo in todos\" :key=\"todo.id\" &gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; （官）永远不要把v-if 和 v-for 同时用在同一个元素上 (性能优化3)一般在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。会获得如下好处： 过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。 使用 v-for=&quot;user in activeUsers&quot; 之后，在渲染的时候只遍历活跃用户，渲染更高效。 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。 通过将 v-if 移动到容器元素，不会再对列表中的每个用户检查 shouldShowUsers。取而代之的是，只检查它一次，且不会在 shouldShowUsers 为否的时候运算 v-for。 Bad 123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\" &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 123456789&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"shouldShowUsers\" :key=\"user.id\" &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; Good 12345678910111213141516&lt;ul&gt; &lt;li v-for=\"user in activeUsers\" :key=\"user.id\" &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt;computed: { activeUsers: function () { return this.users.filter(function (user) { return user.isActive }) }} 12345678&lt;ul v-if=\"shouldShowUsers\"&gt; &lt;li v-for=\"user in users\" :key=\"user.id\" &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 组件销毁时及时清除事件监听、定时器等 (性能优化4)一般在 created 或 mounted 生命周期函数中添加 事件总线和 window上的事件监听或定时器，在 beforeDestroy 或 destroyed 中，添加以上三类事件的移除方法。 12345678910111213created() { this.$eventHub.$on('logged-in', this.getCurrentUser);},beforeDestroy() { this.$eventHub.$off('logged-in');},methods: { getCurrentUser(){ ... }} 12345678910111213mounted() { window.addEventListener('scroll', this.scrollhandle);},beforeDestroy() { window.removeEventListener('scroll', this.scrollhandle);},methods: { scrollhandle(event) { ... },}, 1234567mounted() { this.interVal = setInterval(callback,millisec,args);},beforeDestroy() { clearInterval(this.interVal);} 通过ES6动态导入的方式引入异步组件 (性能优化5)在平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。 基于路由 1234567891011121314151617181920212223import Vue from 'vue';import Router from 'vue-router';import Home from '../views/Home.vue';Vue.use(Router);export default new Router({ routes: [ { path: '/', name: 'home', component: Home, }, { path: '/about', name: 'about', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import(/* webpackChunkName: \"about\" */ '../views/About.vue'), }, ],}); 本地注册 1234567891011121314&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;message&gt;&lt;/message&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { components: { Message: () =&gt; import(\"./Message\") }};&lt;/script&gt; VueX状态管理不要过度使用Store (性能优化6)把所有逻辑移到Store中会导致更多的性能开销和不必要的复杂性。 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 开启严格模式： 1234const store = new Vuex.Store({ // ... strict: process.env.NODE_ENV !== 'production'}) 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 State将数组转化为对象进行存储 (性能优化7)即使从接口中返回的数据就是对象数组的形式，并且视图需要将其显示为使用v-for指令映射的数组，也应考虑将其作为对象放在存储中。 可以轻松地使用ES6+内置的Object.keys，Object.values和Object.entries方法从任何对象中获取数组，但反之则有些复杂。 作为一种算法，通过键从对象中检索到的内容的时间复杂度为O(1)，如果使用搜索或过滤器来查找相同的数据，则是O(n)。 Bad 1234const initialState = { partnersList: [], // array of all partners currentPartner: {}, // current partner object.}; Good 1234const initialState = { partnersList: {}, // object with all partners keyed by ID currentPartnerId: ``, // a string contining the ID of the current partner.}; Getter需要包含一些逻辑如果要访问子属性，通过mapState。 Bad 123getters: { getProducts: state =&gt; state.products,} Good 123getters: { getFeaturedProducts: state =&gt; state.products.filter(p =&gt; p.isFeatured),} 数据冻结 (性能优化8)如果有一个巨大的数组或Object，并且确信数据不会修改，使用 Object.freeze() 可以让Vue不会给对象加上 getter/setter,性能会大幅提升。 在组件中： 123456789export default { data: () =&gt; ({ users: {} }), async created() { const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); }}; 在store中： 1234567const mutations = { setUsers(state, users) { state.users = Object.freeze(users); // 也可以做修改 // state.users = Object.freeze([...state.users, user]); }}; 如果是嵌套对象，则使用深度冻结，也就是遍历对象，用下方的 deepFreeze 替换上边写的 Object.freeze。 123456789101112131415161718/** * 深度冻结对象 * @param target 要冻结的嵌套对象 */function deepFreeze(target) { Object.freeze(target); Object.getOwnPropertyNames(target).forEach((prop) =&gt; { if (target.hasOwnProperty(prop) &amp;&amp; target[prop] !== null &amp;&amp; (typeof target[prop] === 'object' || typeof target[prop] === 'function') &amp;&amp; !Object.isFrozen(target[prop])) { deepFreeze(target[prop]); } }); return target;} 图片压缩 (性能优化9)使用 image-webpack-loader 对图片进行压缩。安装： 1npm i -D image-webpack-loader 在 vue.config.js 中 添加配置： 1234567891011module.exports = { configureWebpack: (config) =&gt; { // 压缩图片 config.module.rules.push({ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [{ loader: 'image-webpack-loader', }], }); }} 使用KeepAlive 按需缓存路由页面 (性能优化10)123&lt;keep-alive include='要缓存的组件名称,要缓存的组件名称'&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 使用CDN或者引入其它服务器上的文件地址实现对静态资源并行请求 (性能优化11)浏览器针对每个域名能创建的最大TCP连接数是有限制的（谷歌浏览器6个），通过将静态资源放在不同的域中可以增加并行请求数。 GZip (性能优化12)使用 Nginx 进行动态压缩，具体请看Nginx相关的文档（待补充）。 其它静态分析使用ESLint作为代码静态分析工具，遵从 Airbnb+自定义风格。 常用插件Vue-Awesome-Swiper：基于 Swiper4、适用于 Vue 的轮播组件。 Vue-Lazyload：图片懒加载。 (性能优化13) vue-svg-icon：可定义svg图标的颜色。 常用工具Octotree：GitHub可视化代码树插件。 npm-check-updates：更新package.json中的所有依赖到最新版本。 资源一张思维导图辅助你深入了解Vue | Vue-Router | Vuex 源码架构 写在最后看过一篇文章，觉得观点挺好的，就直接拿来用了。 Best Practice ：最佳实践。Wikipedia 上对其解释为：A best practice is a method or technique that has been generally accepted as superior to any alternatives because it produbces results that are superior to those achieved by other means or because it has become a standard way of doing things. (最佳实践是一种：因其产生的结果优于其它选择下的结果，或其已经成为一种做事的标准，从而被普遍认可优于任何替代方案的方法或技术。) 最佳实践本身是美好的存在，犹如夜空中的一轮明月，照亮黑暗中的方向，指引着摸索前行的凡人。 但凡事有度，子曰：&quot;过犹不及。&quot; 首先，最佳实践容易带来思想包袱，让人无法专注于解决问题本身。 总是希望采用最好的技术方法，不愿意在不正确的做法上浪费时间，导致瞻前顾后，甚至裹足不前。此时的最佳实践，已然成为了一种毒药，一旦偏离了问题本身这个出发点，就会不知不觉走进&quot;宏大构想&quot;的思维陷阱。把简单的问题复杂化，阻碍了迈出第一步，直到能规划出&quot;包罗万象&quot;的解决方案后才肯动手，拖延症就这样来了，时间却走了。 其次，对最佳实践的执念容易让人钻牛角尖，将目标的重心带偏。 过度关注实施过程是否符合标准化，忽视了项目中其它重要的东西，比如用户体验，比如实际需求。 再次，工程师思维，沉迷于奇技淫巧中无法自拔。 比如性能优化。&quot;优秀的程序员应该榨干每一字节内存&quot;，听起来很熟悉，不是吗？但经济学上来讲，边际效应决定了一次项目中，越优化性价比越低。有一个很容易被忽略的事实：硬件其实比程序员要便宜。 再比如对设计模式的崇拜。设计模式当然是好东西，但如果像强迫症一样使用它们，坚持用上它们才是正确的编程，就会导致按图索骥，强行让问题去适应设计模式，而不是让解决方案针对问题，这就本末倒置了。 最后，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践。 工作数年，大小项目经历若干，慢慢体会到，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践，更多的时候，取决于开发方案和技术储备之间的平衡。做项目毕竟是要讲方案落地的，如果最佳实践中的技术成本，超出了开发者的落实能力，那就是坑，这时盲从最佳实践无异于挖坟。如果是一个人的项目，抽时间恶补一通，兴许能填填坑，这取决于IQ。但要是一个团队，那就不是什么 IQ，EQ，QQ 的问题了，这中间产生的学习成本，集体培训成本，反复沟通成本，大量的初级错误，千奇百怪的代码，互相冲突引发的焦躁情绪等等。这些负面的东西如果不能妥善的处理，足以抵消掉最佳实践带来的好处。别忘了，deadline 正在迫近。 当尘埃落定，蓦然回首，最佳实践很可能没你想象中那么重要。它更多的是一种精神层面的求道，并非物质世界的必要。 全篇能全部看下来，觉得自己基础扎实，想在前端道路上有进一步发展的请加微信： zapzqc只要你肯努力，这里将会为你提供充足的发展空间。","link":"/2020/04/29/Vue-js2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"从零开始搭建前端项目开发环境","text":"写在最前为何大多数人觉得搭建一个前端项目的开发环境很困难。首先，一个完整的开发环境需要依赖多个工具，每个工具又有不计其数的配置项，想要全部理解需要花费大量的时间。其次，一些官方文档中文翻译滞后，而且结构组织的也不是很好，没有从一个具体的项目出发讲解如何配置，只看API没有什么针对性。最后，好多国内相关博客要么没有标注工具的版本，导致按照步骤进行配置时会发现自己下载的和讲述的某些地方会不一致；要么只讲如何配置，不讲配置的原因，导致大家仍是云里雾里。不过所幸，大部分CLI实现了脚手架的功能，帮助快速生成项目，而不用了解工具的具体配置。 但是，作文里总会有个转折不是。当我们需要自己独立去创建一个项目的时候…该怎么办哖，Don’t be afraid，I’m here. 接下来会先介绍一下几个常用工具（Babel 7.9.0，Browserslist 4.11.1, ESLint 7.0.0, EditorConfig）的核心概念、安装和配置，最后会结合 TypeScript + SASS + webpack5 的项目来说如何将它们整合起来形成一个完整的前端项目开发环境。 Here we go. Babel (7.9.0)Babel是一个Javascript编译器。主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容(backwards compatible)的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其它环境(如：node)中。 安装123npm i -D @babel/core @babel/cli @babel/preset-envnpm i -D core-js 运行此命令之前要先初始化项目，新建项目文件夹 xxx , 在该文件夹下 运行： 1npm init 尽量不要一路回车，建议按实际内容来。 @babel/core主要用于将源代码(JS\\TS)解析为AST(抽象语法树)。 @babel/cli用于从命令行编译文件。 @babel/preset-env预设环境。源代码解析成AST后，还需要进行转换和生成，这是由插件来做的。@babel/preset-env(预设环境)是常用预设和插件的集合（babel-preset-es2015，babel-preset-es2016，babel-preset-es2017，babel-preset-latest，babel-preset-node5, babel-preset-es2015-node等，@babel/preset-env不支持stage-x插件）。 最初每年EcmaScript标准更新，都需要使用者手动添加最新年份的预设才能进行新语法的转换: 12345&quot;presets&quot;: [ &quot;es2015&quot;, &quot;es2016&quot;, &quot;es2017&quot; ], 后来改成了 babel-preset-latest，意思为最新的预设（包含了以往所有年份），不用每年都需要手动添加一把。最终 latest 也被废弃，变成了目前的 preset-env。开发人员可以在代码中直接书写已经正式发布的特性。不过，当ES更新时，肯定还需要更新一下 @babel/preset-env。 core-jsBabel 默认只转换新的 JavaScript 语法，如： 类、箭头函数、扩展运算（spread），而不转换新的 API ，如：Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（如：Object.assign）。不转码的 API 详细清单可以查看 definitions.js 文件。 core-js 提供了es5、es6+的polyfills(填充物，用于实现浏览器并不支持的原生API的代码，它将一个新的 API 引入到一个旧的环境中，仅靠旧环境中已有的技术手段实现)，包括promises, symbols, collections, iterators, typed arrays等等。 这里不得不提一下该库和它的俄罗斯作者。该库一周的下载量比大家熟知的 Angular、 React、Vue加一起的下载量还要多的多。就这样的一个库谁能想到它的作者竟然需要在命令行里 looking for a good job，后来该作者又因为骑摩托车撞死一人，伤一人，被判入狱18个月, 现在应该已经处于服刑期间了… @babel/polyfill 已废弃。 配置可以在三类文件中对Babel进行配置，在项目的根目录中创建babel.config.*、.babelrc.* (* 可为 空，json, js, cjs 或 mjs) ，或在package.json中添加。 如果扩展名为 json，那一般的内容是： 1234{ &quot;presets&quot;: [...], &quot;plugins&quot;: [...]} 如果扩展名为 js，则内容为： 1234const presets = [ ... ];const plugins = [ ... ];module.exports = { presets, plugins }; 在 package.json 中： 123456789{ &quot;name&quot;: &quot;my-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;babel&quot;: { &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [ ... ], }} 我们一般使用 babel.config.js 作为配置文件，因为在JS中可以写注释，方便理解（JSON不方便）。其它工具的配置文件能采用 js 做扩展名的也尽量使用 .js。 在项目文件夹下创建 src 目录，新建 index.js。编写内容： 12345const userInfo = new Map();userInfo.set('name', '天下布武');userInfo.set('age', 18);console.log(Object.entries(userInfo)); 在package.json中添加： 123&quot;scripts&quot;: { &quot;build&quot;: &quot;./node_modules/.bin/babel src/index.js --out-dir dist&quot;}, @babel/preset-env最简设置如下(不建议，转换后会多出很多冗余代码，至少要配置一个targets)： 1234567module.exports = { presets: [ [ '@babel/preset-env', ], ],}; 在命令行中运行： 1npm run build 就能在新生成的dist文件夹中看到 编译后的 index.js ： 可以看到之前的 const 被转译成了 var。 下面对两个常用参数进行说明： targets设置编译代码的目标平台，可以是浏览器也可以是node环境。如不设置，会将所有ES6+的代码编译为ES5-。建议设置，这样可以按目标平台来决定是否进行转换，以避免增加不必要的补丁，减少打包后的代码体积。 常见设置如下： 123456789module.exports = { presets: [ [ '@babel/preset-env', { targets: '&gt; 1%, last 2 versions, ie &gt; 8', }, ], ],}; 以上配置的意思是要兼容全球范围内使用量大于1%的浏览器和它们最新的两个版本，加上IE 9-11。这里既可以指定浏览器的版本，也可以通过查询的方式来确定要支持的浏览器。详情见Browserslist这一章节。 若设置 targets: ‘&gt; 10%’ , 再运行一次 npm run build ，因为大于 10% 的浏览器只有谷歌，它是支持 const 的, 因此编译结果几乎原封未动： 建议使用 .browserslistrc 文件来定义targets，这样其它工具(Autoprefixer、PostCSS、Stylelint 等)也能通过该配置获取到目标浏览器，从而做有针对性的处理。 useBuiltIns是否内置兼容。如果设置，就可以不用在HTML中引入polyfill的JS文件来处理浏览器的兼容性问题了。常见设置如下： 1234567891011module.exports = { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: 3, }, ], ],}; 可选值包括：”usage” | “entry” | false。 false：默认值，即不引入polyfills，不做浏览器兼容。 entry：根据配置的浏览器，引入这些浏览器不兼容的polyfill。这个是在文件中已经明确写了import “core-js” 或其中具体某个模块（如：import “core-js/es/array”）的情况下，babel会根据 browserslist 自动添加指定浏览器不兼容的该模块下的所有polyfill，无论当前代码是否需要。 usage：会根据配置的浏览器以及代码中用到的 API 自动添加polyfill，实现了按需引入。一般使用这个配置。 只有当 useBuiltIns 的值为 entry 或 usage 时，”corejs” 这个选项才会起作用。这里如无特殊情况尽量指定 core-js 的版本为 3（默认为 2）, 因为它有很多2没有的新特性： “corejs”: 3。 这里运行 npm run build, 运行结果为： 可以看出它在全局作用域下添加了 Map 变量，同时在 Object 原型中添加了 entries 方法。 babel默认转出的是模块规范为 commonJS，只能在 Node 环境中使用，如果想在浏览器环境中使用，一般有两种方式：1、 结合 rollup2、 结合 webpack我们一般使用 第二种方式，参看最后 webpack 实例。 @babel/plugin-transform-runtime对于一般应用开发来说，直接使用上述的 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合(由上图可以看出，polyfill 是添加自定义全局对象 或向对象的 prototype 上添加方法实现的)。使用 @babel/plugin-transform-runtime 这个插件就可以解决这个问题。 安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 配置： 123456789101112131415module.exports = { presets: [ [ '@babel/preset-env', ], ], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 该插件无法读取 preset-env 的 targets 或者是 browserlist 中的目标平台参数，因此不会根据目标平台来决定是否进行转换和注入 polyfills，而是全转换和注入所有。以后可能会在 useBuiltIns 中增加一个参数 “runtime” 来代替该插件。可参见：https://github.com/babel/babel/issues/10133 再运行 npm run build，得到： 凡是require进来的模块都直接赋值给普通变量，不会对 Map 、 Object 等全局变量造成影响。 注：这里的和上边所有提到的“编译”一词更准确的说法应该是“转译（Transpile）”。 Browserslist (4.11.1)Browserslist 是一个能够在不同的前端工具间共享目标浏览器的配置。看配置就知道当前项目支持的浏览器有哪些。它使用 Can I Use 的数据做查询。 在项目中添加 Browserslist，常用有两种方式(不能同时在 .browserslistrc 和 package.json 中配置，否则使用 Babel 转译的时候会报错)： 在项目的根目录下添加 .browserslistrc 文件 123&gt; 1%last 2 versionsie &gt; 8 在package.json文件中增加 browserslist 节点 1234567891011{ &quot;private&quot;: true, &quot;dependencies&quot;: { }, &quot;browserslist&quot;: [ &quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;ie &gt; 8&quot; ]} 查询结果可通过 https://browserl.ist/ 来查看。 运行命令行： 1npx browserslist 可查看当前项目目标浏览器列表。*如果只是在 babel.config. 文件中配置了 target 是检测不出来的（会优先使用），因此建议使用 单独的 .browserslistrc 来设置。** ESLint (7.0.0)是一个可以查找并且修复JavaScript(TypeScript)中错误的工具，目的是为了保证代码风格统一，避免出错。 概念extends（扩展）扩展里填的内容是包含了一系列规则的配置文件。这个一般不需要自己定义，因为有很多现成的：如ESLint自身的 eslint:recommended、eslint:all 和社区的 google、airbnb。 配置的模块名(npm的包名)要为 eslint-config-xxx，在配置中可缩写为 xxx。 例： plugins（插件）extends 中是对 eslint 现有规则的一系列预设（开启或关闭），而 plugins 不仅可以定义预设，也可以自定义规则（比如自己创建一个 no-console2，区别于ESLint的 no-console），甚至可对不是JavaScript类型的文件（如 *ts，*.md，*.vue）扩展自己的规则。 插件的模块名一般为 eslint-plugin-xxx，在配置中可缩写为 xxx。 例： rules（规则）直接配置已有规则的开启、关闭。比如强制在JavaScript中使用单引号（”quotes”: [2, “single”]）。规则定义中参数的设置说明： “off” 或 0：关闭规则 “warn” 或 1：警告，不会影响程序执行 “error” 或 2：错误，程序不能执行 安装针对 JavaScript1npm i -D eslint eslint-config-airbnb-base eslint-plugin-import eslint-config-airbnb-base包含了airbnb 最基础（不包含 React 相关）的JS编码风格规则。 eslint-plugin-import上边的插件依赖这个。😛 针对 TypeScript1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin eslint-config-airbnb-typescriptAirbnb 风格的 TypeScript 支持。它将一些常见配置都加了进去，省下了好多工作量。ps. 这是一个匈牙利布达佩斯技术和经济大学的学生做的，想想自己的大学生活都在做啥… 该插件包含了@typescript-eslint/parser（TypeScript 解析器），它调用@typescript-eslint/typescript-estree（通过在给定的源代码上调用 TypeScript 编译器，就是 npm i typescript -D 安装的那个，以产生TypeScript AST，然后将该AST转换为ESLint期望的格式）。ESlint默认的解析器叫 espree。 @typescript-eslint/eslint-plugin与 @typescript-eslint/parser 结合使用时，运行 TypeScript 的分析规则。 配置可使用 .eslintrc.( 可为 空，js, yaml, yml, json）或在 package.json 中配置，这里使用 .eslintrc.js 来进行配置。 一个项目中在不同的文件夹下可以有多个 .eslintrc. 配置文件，这样可以约束不同文件夹下的文件使用不同的风格，这一点和 editorConfig 一样。 针对 JavaScript一般配置如下： 12345678910111213141516module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, es2020: true, }, extends: 'airbnb-base', // 使用airbnb风格 parserOptions: { ecmaVersion: 2020, // 启用ES2020的语法 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 针对 TypeScript一般设置如下： 1234567891011121314151617181920module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 最后要在 VS Code 中安装 ESLint 插件，配置相关参数，使之能够在文件保存时自动修复格式错误；WebStrom中则需设置允许 ESLint（最新的2020.1.1 版本中也能够在文件保存时自动修复错误）。 EditorConfig帮助在不同的编辑器或IDE上从事同一项目的多个开发人员保持一致的编码样式。 一个项目里可以有多个.editorconfig 分别放置在不同的文件夹中，当 VS Code 这类编辑器打开一个文件时，它会检查这个文件所在目录和它的父级文件夹（直到项目根目录或者是是某个文件夹中的 .editorconfig 里标识了 root = true 才会停止)中是否存在 .editorconfig。被打开的文件格式会以距当前文件最近的 .editorconfig 中的内容为准。 一般配置如下： 1234567891011121314# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行[*.md]insert_final_newline = falsetrim_trailing_whitespace = false webpack (v5.0.0-beta.16)webpack是用于现代 JavaScript 应用程序的静态模块打包器。当webpack处理应用程序时，它会在内部构建一个依赖关系图，该图映射项目所需的每个模块最终会生成一个或多个包。 概念moduleswebpack中，无论是 JS 、CSS 还是图片等，总之一切皆模块。 有点像RxJS，一切皆数据流。模块间依赖的表述有很多种方式，如：import，require，define，@import，url(…), &lt;img src=…&gt; 等等。 Entry &amp; Output入口指示webpack应该使用哪个模块开始构建其内部依赖关系图。默认为： ./src/index.js。 出口告诉webpack在何处发出它创建的包文件以及如何命名这些文件。默认为： ./dist/main.js Loaderswebpack 默认只能解析JavaScript和JSON，可以通过添加 Loaders 来处理其他类型的文件。 Plugins可以利用插件来执行更广泛的任务，例如打包优化，资产管理和环境变量的注入。 Mode分development、production、none三种，每种都会对应一系列默认配置。 实战接下来以初始化一个 TypeScript + SCSS 项目为例，介绍下webpack5的配置流程。 在开始之前先说下，为何没用 ts-loader 和 TSLint： 由于 TSLint 的性能不如 ESLint，再加上有很多热门的社区（React Hooks、Vue），都是通过 ESLint 来构建规则，因此，TypeScript 团队决定专注支持 ESLint。 Babel7 虽然不支持TS类型检查，但已经支持转译。 构建需要安装的插件、工具太多，能少一个就少一个，一个编译器既能支持JS，又能支持TS，为何不用。因此，感觉 ts-loader 的生命也不会太长了… Node 环境要求至少为：10.13.0。 初始化项目1npm init 在命令行中填入项目相关信息，不建议一路回车… 安装 webpackwebpack@next 是最新的 webpack5。不写@next，就是 webpack4。 1npm i -D webpack@next webpack-cli 如果需要一个web服务器做调试和热更新，则需安装： 1npm i -D webpack-dev-server 创建 .editorconfig统一编码样式。 1234567891011121314# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 安装 TypeScript 编译器并配置安装编译器的目的是为了配合ESLint做代码检查和自动修复。 1npm i -D typescript 在项目根目录下创建 tsconfig.json，其中可定义入口文件以及编译的参数，用于将 TypeScript 转译为 JavaScript。 一定要设置，否则在IDE做语法校验的时候，新JavaScript API（如： Object.fromEntries ）会报错。 12345678{ &quot;compilerOptions&quot;: { &quot;lib&quot;: [ &quot;ESNext&quot;, &quot;DOM&quot; ] }} ESNext 指的是TypeScript支持的最新版本的ES。它会随着ES版本的更新而自动更新，一劳永逸。DOM 类型定义，允许在TS中直接写window，document。 安装 ESLint 并配置1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin .eslintrc.js 1234567891011121314151617181920module.exports = { root: true, // 这个配置同 editorConfig，意思是不要找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 创建 .gitignore提交Git服务器时，忽略的文件列表。使用SVN的就不需要这个了。 12345678910111213141516171819202122.DS_Storenode_modules/dist# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw?.git 创建 .browserslistrc这里设置兼容IE11。当前项目如果是作为库使用的话，该设置不会起作用。详情见：babel-plugin-transform-runtime 123&gt; 1%last 2 versionsnot ie &lt; 11 安装 webpack loaders所有 Loaders 都在 webpack.config.js 文件中的 module 节点中进行添加。 转译babel-loader及相关webpack本身只能打包（模块合并）而没有转译的能力，TS转译成JS用的是 Babel ，并没有使用 TypeScript 编译器。 123npm i -D babel-loadernpm i -D @babel/core @babel/preset-env @babel/preset-typescript core-js babel.config.js： 123456789module.exports = { presets: [ [ \"@babel/preset-env\",{ \"useBuiltIns\": \"usage\", \"corejs\": 3 }], \"@babel/preset-typescript\" ]} webpack.config.js 片段: 12345678910module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, // 匹配扩展名为 .ts,.js,.tsx.jsx 的文件 use: 'babel-loader', // 使用 babel-loader 来进行解析 exclude: /node_modules/, // 排除 node_modules 文件下的文件 }, ]} 更多配置可见下方完整的配置。 当前项目将要作为库的话，还得安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 同时 babel.config.js 中的配置改成下面这个： 1234567891011121314module.exports = { presets: [ '@babel/preset-env', '@babel/preset-typescript', ], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 样式sass-loader加载 SASS/SCSS 文件 并将其编译为 CSS。 1npm i -D sass-loader node-sass sass-loader 要求要安装 Dart Sass 或者是 Node Sass。弄过 NPM 下载下来的这两者只是个编译器。据说前者在node环境中性能比后者要差，因此一般都会使用 node-sass。 webpack.config.js 一般配置如下： 1234567891011121314// 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 从字符串中创建style标签到HTML的Header中 'style-loader', // 转换CSS为字符串 'css-loader', // 给CSS添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, postcss-loader PostCSS是CSS语法转换的工具。它提供API来对CSS文件进行分析和修改它的规则。利用其插件 autoprefixer ，可以给 CSS 添加目标浏览器（Browserslist中定义的）前缀。 1234-moz- /* 火狐等使用Mozilla浏览器引擎的浏览器 */-webkit- /* Safari, 谷歌浏览器等使用Webkit引擎的浏览器 */-o- /* Opera浏览器(早期) */-ms- /* Internet Explorer */ 1npm i -D postcss-loader autoprefixer 创建 postcss.config.js, 定义 PostCSS 的插件为 autoprefixer： 12345module.exports = { plugins: { autoprefixer: {}, },}; css-loader加载CSS文件，并以JS模块（CSS样式以字符串的形式封装在其中）的形式返回。 如果只使用 css-loader，解析出的CSS内容都在打包后的js代码中，没有任何作用。 只有配合 style-loader 或 mini-css-extract-plugin 等，引用的样式才会起作用。 1npm i -D css-loader style-loader将CSS样式注入到DOM中。默认是在&lt;header&gt;最后添加&lt;style&gt;，这是通过生成JS方法动态添加的。 1npm i -D style-loader 一般这样配置： 1234{ test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'],}, 文件url-loader将小于一个限制大小的文件转换为base64 URIs。超过限制的，会默认使用 file-loader来做处理。所以这里一定要把 file-loader 也安装上。 1npm i -D url-loader file-loader file-loader生成文件到输出的文件夹中，并返回相对路径URL 。 1npm i -D file-loader 安装 webpack pluginsHTMLWebpackPlugin会生成一个HTML5文件，其中body中会加入所有webpack打包出来的内容。 1npm i -D html-webpack-plugin clean-webpack-plugin移除或清空构建出的文件夹。 1npm i -D clean-webpack-plugin mini-css-extract-plugin将CSS提取到单独的CSS文件中。 1npm i -D mini-css-extract-plugin 一般的配置如下： 12345678910111213141516171819202122232425262728293031const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); module: { rules: [ ... { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, ], },plugins: [ ...js new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }),], webpack-bundle-analyzer可视化webpack输出文件的大小。 1npm i -D webpack-bundle-analyzer 1234567const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');module.exports = { plugins: [ new BundleAnalyzerPlugin() ]} 创建 webpack.config.js配置webPack来处理TypeScript。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const { CleanWebpackPlugin } = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const path = require('path');const config = { entry: './src/index.ts', // 入口文件 externals: { cesium: 'Cesium', }, module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, use: 'babel-loader', exclude: /node_modules/, }, // 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, // 使用 url-loader 将小于 4KB 图片 转换为 base64 URIs { test: /\\.(png|jpe?g|gif|webp)$/i, use: [ { loader: 'url-loader', options: { name: 'images/[name].[hash:8].[ext]', limit: 4096, esModule: false, }, }, ], }, ], }, resolve: { extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'], // 按顺序解析以上扩展名的文件(必须添加，否则通过import进来的文件无法解析。import时可不写扩展名 默认值为 ['.wasm', '.mjs', '.js', '.json'] }, output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: 'public/index.html', title: 'TypeScript-Webpack-starter' }), new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }), ],};module.exports = (env, argv) =&gt; { if (argv.mode === 'development') { config.devtool = 'source-map'; // 导出SourceMap供调试 } if (argv.mode === 'production') { } return config;}; 某些开源项目会在项目的根目录下创建一个 build 文件夹，将 webpack 的配置拆分为base(存放公用配置)、dev(开发环境特有的配置)、prod(生产环境特有的配置)，利用合并插件将dev或prod和base合并。个人认为其拆分的思想没有问题，但如果配置项没达到一定规模(500行以上?)可以不用这么麻烦。如上方配置所示：只使用 webpack.config.js ，先添加公用配置(一个对象)，然后通过判断当前是开发还是生产模式，补充相应配置。 添加脚本package.json 12345 \"scripts\": { \"serve\": \"webpack-dev-server --mode development --open\", \"dev\": \"webpack-dev-server --mode development --open\", \"build\": \"webpack --mode production\" }, 形成项目结构创建libs、public、src文件夹 123456789101112131415161718├── libs // 第三方库├── public│ ├── index.html├── src│ ├── assets // 资源│ │ ├── images // 图片│ │ ├── styles // 样式文件 scss、less、css│ └── index.ts├── .browserslistrc├── .editorconfig├── .eslintrc.js├── .gitignore├── babel.config.js├── package.json├── postcss.config.js├── README.md├── tsconfig.json└── webpack.config.js 其中index.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 源码地址https://github.com/THS-FE/typescript-webpack-starter 备注为什么好多配置文件的后缀是 rc [Unix: from runcom files on the CTSS system 1962-63, via the startup script /etc/rc] Script file containing startup instructions for an application program (or an entire operating system), usually a text file containing commands of the sort that might have been invoked manually once the system was running but are to be executed automatically each time the system starts up. rc代表短语 runcom （运行命令），unix的爷爷CTSS系统中的脚本文件，里边包含了应用或者整个系统启动时要执行的命令。 现在更通用的含义可能是 runtime configration，即应用运行时的配置。 参考：https://stackoverflow.com/questions/11030552/what-does-rc-mean-in-dot-files https://unix.stackexchange.com/questions/3467/what-does-rc-in-bashrc-stand-for","link":"/2020/05/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"前端开发必须掌握的基本概念","text":"编译型(compiled) VS 解释型(interpreted)计算机语言通常分为三类：即机器语言，汇编语言和高级语言 机器语言（machine language）（1）概念：机器语言是用二进制代码(0和1)表示的、计算机能直接识别和执行的一种机器指令的集合。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。 （2）特点：不同种类的计算机其机器语言是不兼容的，按某种计算机的机器指令编制的程序不能在另一种计算机上执行。在现今，除了计算机生产厂家的专业人员外，绝大多数程序员已经不再学习机器语言。 （3) 示例 图1 机器语言 （4）指令集架构 又称指令集或指令集体系（英语：Instruction SetArchitecture，缩写为ISA），是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部I/O。指令集架构包含一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。 计算机微处理器的指令集架构（Instruction Set Architecture）常见的有两种： 精简指令集运算（Reduced Instruction SetComputing，RISC）：该指令集较为简单，每个指令的运行时间较短，完成的操作也简单，指令的执行性能较佳；但是要做复杂的事情，就需要由多个指令配合完成。当前有UNIX、Linux、MacOS以及包括iOS、Android、WindowsPhone、WindowsRT等在内的大多数移动操作系统运行在精简指令集的处理器上。 复杂指令集运算（Complex Instruction SetComputing，CISC）：与RISC不同的是，CISC在指令集的每个小指令可以执行一些较低级的硬件操作，指令数目多而且复杂，每条指令的长度不同。因为指令执行较为复杂，所以每条指令花费的时间较长，但每个指令可以处理的工作较为丰富。常见的CISC指令集的CPU有AMD、intel、VIA等X86架构的CPU。当前x86架构微处理器如Intel的Pentium/Celeron/Xeon与AMD的Athlon/Duron/Sempron；以及其64位扩展系统的x86-64架构的Intel64的Intel Core/Core2/Pentium/Xeon与AMD64的Phenom II/Phenom/Athlon64/Opteron/Ryzen/EPYC都属于复杂指令集。主要针对的操作系统是微软的Windows和苹果公司的OSX。另外Linux，一些UNIX等，都可以运行在x86（复杂指令集）架构的微处理器。 参考：https://www.processon.com/view/link/5dad48c8e4b0e4339303ebe2 汇编语言（assembly language） 概念：是用与代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码的一种符号语言（汇编语言亦称符号语言）。所以说,汇编语言是一种用助记符表示的仍然面向机器的计算机语言。 特点：机器语言和汇编语言都是面向硬件(CPU)的语言，语言对机器过分依赖。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。使用汇编语言编写的源代码，然后通过相应的汇编程序将它们转换成可执行的机器代码。这一过程被称为汇编过程。 （3）示例：如用ADD表示运算符号“＋”的机器代码 图2 汇编语言 高级语言（High-level programming language）（1）概念：高级编程语言是高度封装了的编程语言。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。由于早期电脑业的发展主要在美国，因此一般的高级语言都是以英语为蓝本。 （2）示例：现在开发人员使用的大部分都是高级语言，如Java、JavaScript、Python等等 （3）特点：高级语言是面向用户的语言。无论何种机型的计算机,只要配备上相应的高级语言的编译或解释程序,则用该高级语言编写的程序就可以通用 编译型语言和解释型语言 分类依据根据高级程序语言的运行方式不同，分为两种：编译型语言和解释型语言 根本区别：把高级语言编译成机器语言，执行这个编译过程的时机不同，即运行方式不同 概念（1）编译型语言 在程序运行之前：使用针对特定CPU体系的编译器，将源代码（高级程序语言编写的代码）一次性的编译成目标代码（机器语言编写的代码）（源代码——机器码）； 程序运行时，直接运行编译好的目标代码； 再次运行时，可直接使用上一次编译好的机器码，不需要重新编译。 (2) 解释型语言 程序运行时：即边编译边运行，每编译一行程序（高级语言——机器语言），就立刻运行，然后再编译下一行，再运行，如此不停地进行下去； 再次运行时，需要重新进行编译。 （3）比较 图3 高级语言执行过程 用解释器来运行程序会比直接运行编译过的机器代码来得慢，但是相对的这个解释的行为会比编译再运行来得快。这在程序开发的雏型化阶段和只是撰写试验性的代码时尤其来得重要，因为这个“编辑-解释-调试”的循环通常比“编辑-编译-运行-调试”的循环来得省时许多。所以解释型语言可以达到较快的开发速度，编译型语言可以达到较快的运行进度之间。 常用语言分类编译型语言：C、C++ 解释型语言：JavaScript、Python、MATLAB、TypeScript 总结编译型与解释型，两者各有利弊。 Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。 既然编译型与解释型各有优缺点又相互对立，所以一批后来诞生的语言都有把两者折衷起来的趋势。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。 其他概念【源程序】又叫源码，用非机器语言书写好的符号程序称源程序 【目标程序】指源程序经编译后可直接被不同CPU架构运行的机器码集合 图4 编译器 图5 解释器 转自：https://blog.csdn.net/qq_41026740/article/details/96009765 https://www.cnblogs.com/clemente/p/10413618.html 静态类型(Static Typing) VS 动态类型(Dyn amic Typing)分类标准编程语言里会有类型检查的机制，类型检查的目的是避免程序发生一些未预料到的错误。 编程语言按照类型检查可以分为两大类：静态类型和动态类型。二者的根本区别在于：进行类型检查的时机，类型检查可以理解为：确定变量的类型，并实行类型的约束操作（类型转换） 概念 静态类型 在运行前进行数据类型检查的语言，即静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型 动态类型 在程序运行时才做数据类型检查的语言，即动态类型语言中，声明变量时无需指定类型，第一次将某类型的数据赋值给变量，在内部会将数据类型记录下来，成为该变量的类型 【注意】静态类型在编译型语言中较为普遍，动态类型在解释型语言中较为普遍，但不是绝对的，如TypeScript是解释型语言，静态类型语言 讨论静态类型在程序运行前，就能可靠地发现类型错误。因此通常能增进最终程序的可靠性。然而，有多少的类型错误发生，以及有多少比例的类型错误能被静态类型所捕捉，目前对此仍有争论。静态类型的拥护者认为，当程序通过类型检查时，它才有更高的可靠性。但是动态类型的拥护者指出，大部分软件证明，两者在可靠性上并没有多大差别。 常用语言分类静态类型语言：Java、C、C++、TypeScript 动态类型语言：JavaScript、Python 【补充】前端最常用见的10个错误中，有7个是类型错误，ts它是静态类型语言。在没运行的时候，IDE就帮我们做类型检查了，能减少错误，所以前端开发就这方面而言ts优于js。 转自：https://www.jianshu.com/p/bc492fcbf18f 强类型(Strong Typing) VS 弱类型(Weak Typing)分类标准按编程语言对类型检查的严格程度的强弱之分：分为强类型定义语言和弱类型定义语言 概念 强类型语言 一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了 2、弱类型语言 对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生，包括相关类型之间隐式转换和不相关类型之隐式间转换 常用语言分类强类型语言：Python、Java、C# 弱类型语言：JavaScript、TypeScript 【注意点】“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的 例如： Python是动态语言，是强类型定义语言（类型安全的语言） JavaScript是动态语言，是弱类型定义语言（类型不安全的语言） JAVA是静态语言，是强类型定义语言（类型安全的语言） 对强弱类型的深入理解虽然对这两个词是这样定义的，但是在技术含义上这两个术语尚未达成共识。相比之下，静态类型化意味着程序在执行之前就经过检查，程序可能在启动前被拒绝。动态类型化意味着在执行过程中会检查值的类型，而类型错误的操作可能会导致程序停止运行或在运行时发出错误信号。静态类型化的主要原因是要排除可能具有此类“动态类型错误”的程序。 强类型通常意味着类型系统中没有漏洞，而弱类型意味着类型系统可以被破坏。但是C语言，在编译时对语言进行类型检查（静态类型），但是仍然存在很多漏洞。几乎可以将任何类型的值转换为相同大小的另一类型，特别是可以自由地转换指针类型。 所以不同的人对“强”和“弱”两个程度副词的理解和定义是不同的。所以避免使用这两个词对语言做区分。 转自：https://blog.csdn.net/m0_37828249/article/details/87971474 集成开发环境(IDE(IntegratedDevelopmentEnvironment)) VS 编辑器(Editor)概念 1、编辑器 就是基于对一个文件、一个视频、一串数字等进行编辑或者再次编辑的工具。一般是为了文件、视频或者字符有更好的体现功能才进行的编辑，总的来说大概就是修改与编写的意思，可编写代码，也可编写文字，编辑图片等。常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器，视频编辑器等 示例：Notepad++等 2、IDE 集成开发环境（IDE，Integrated Development Environment）,是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。编译器、编辑器、调试器都可以属于IDE，如微软的VisualStudio系列，Borland的C++Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。 简单说，就是集成了编辑器、编译器以及链接器等众多功能的一个集成开发环境。 示例：Visual Studio系列、webstorm等(vs code加上它一大堆插件) 转自：https://blog.csdn.net/pointer_5/article/details/94242888 语法糖(Syntactic sugar) VS 语法盐(syntactic salt)概念 语法糖 语法糖是在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一模一样，只是更方便程序员使用，让程序更加简洁，有更高的可读性 示例：ES6的箭头函数、解构赋值等 2、语法盐 语法盐是指那些为避免容易犯的语法错误加上的额外语法限制。这些特性强迫程序员做出一些基本不用于描述程序行为，而是用来证明他们知道自己在做什么的额外举动。 示例： 类型检查 有人建议在用end if, end while等代替现在的统一的end C++ 通过引入 static_cast、reinterpret_cast、const_cast 和 dynamic_cast这四种转换来强迫程序员多敲键盘，从而令他们少用转换 C#在switch语法中的case标记代码块内，如果没有goto、return、throw跳离语法，一定得加上break语法 如果非常仔细、小心，这些语法盐可能就是多余的 转自：https://segmentfault.com/a/1190000010159725 重复发明轮子(Reinvent the wheel)来源我们都知道轮子应该是圆的最省力，但是当我们的祖先不知道什么形状最省力的情况下，就可能会发明出三角轮、四边轮、五边轮等等。当大家都知道圆形的轮子是最省力的，是最好的形状之后，再发明其他形状的轮子就没有什么意义了。当大家都知道圆形的轮子是最省力的、是最好的形状之后，如何改进现有的圆形轮子，才是最重要的。 为什么是轮子因为轮子是人类历史上最伟大的发明之一。轮子是人类的早期发明物之一。早期的轮子，是光滑的圆木，人们借助于这些圆木在地面上移动物体。历史上没有记录表明轮子是在什么年代、由谁发明的。然而，当“第一个发明者”把轮子安装在轴上时，人们就开始利用轮子把物体从一个地方移动到另一个地方。人们发现，在公元前2000年埃及古文物中，便有了轮子；古代中国文明也有发明使用轮子的记载和考古发现。 尽管轮子如此强烈地吸引着人类，可是人们却花费了几个世纪的时间来建造使用轮子的机器，而且大约有400多年，轮子的基本形状一直没有变化。 概念 概念 是指前人已经指明了方向，我们需要了解之前轮子的原理和利弊，加以改进或修改，使它更好或者满足自己新的需求。 2、示例 Linus在上大学的时候，他觉得老师教学用的操作系统Minix不够好用，于是就自己写了一个操作系统来代替，这东西就叫Linux,市场份额占到了服务器市场的一半甚至更多在与其他人开发Linux的过程中，他们一直使用的版本控制系统Bitkeeper终止了授权，而Torvalds觉得其他的版本控制系统太蠢了，于是花了一周又自己写了一个东西，叫做Git。于是这个东西又占到了版本控制系统市场的七成甚至八成以上的份额。 脚手架(Scaffolding)概念在计算中使用的脚手架指的是两种技术之一： 第一种是与某些MVC 框架中的数据库访问相关的代码生成技术; 第二种是由各种工具支持的项目生成技术。 “脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多MVC框架都有运用这种思想。程序员编写一份specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份specification生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用。 前端开发中脚手架的作用是创建项目的初始文件，本质是方案的封装。前端工程体系的功能涵盖范围广，封装的方案类型多，对应的配置项也非常复杂。而且，大多数前端工程体系的开发者并不是一线的业务开发者。对于业务开发者来说，这套工程体系就是一个黑盒，他们不需要了解其中的复杂原理，只需要知道如何配置即可。所以业务开发者的需求就是快速开发快速配置，并且生成的配置项跟项目要对应，既要满足项目的功能需求，又不能有“混淆视听”的冗余功能。 CLI(command-line interface)CLI为command-line interface的缩写，意为：命令行界面，是脚手架的实现方式之一。VueCLI 是一个 Vue.js快速开发的完整系统（或者俗称为：命令行工具），它所具有的一项功能是：快速搭建繁杂的单页面应用。 vue的 clivue是一套渐进式（就是你需要什么就用什么，不需要什么就可以不用，强制你遵守的规则很少），自底向上增量开发（就是根据系统和硬件编写出基层的基本需求代码，再慢慢增加模块），由于他要求遵守的规则较少，你可以引不同自己需要的东西，就需要配合webpack打包工具把引入的不同模块的东西打包 webpack是一个工具，俗称打包工具，就是把所以浏览器不能识别的东西如（less，scss）等转换为浏览器可以识别的语言如（css），因为vue中需要引入大量的各种各样的模块所以很依赖webpack 。在webpack看来 一切皆模块。 cli他能快速生成webpack打包结构，就跟‘！’可以动态生成html框架一样。 转自：https://blog.csdn.net/pojpoj/article/details/100737194 银弹(Silver Bullet)来源 在古老的传说里，狼人是不死的。想要杀死狼人有几种方法： １.像杀死吸血鬼那样用木桩钉住狼人的心脏； ２.将月光遮住 ３.用银子做的子弹射穿透狼人的心脏或头 当然现实中是没有狼人的。但现实中确实有银弹这个东西。而其意义也类似于能杀死狼人的最好办法。现实中的狼人可以是一个棘手的项目，或者一件不可能的事。而“银弹”就是指能解决这些事的方法，或者技术手段。如果看过《人月神话》，那一定对银弹这个词并不陌生。不过在IT行业中，只有张嘴不办事的人会去幻想银弹技术。《没有银弹》（NoSilver Bullet）是IBM大型电脑之父佛瑞德·布鲁克斯（FredBrooks）在1987年所发表的一篇关于软体工程的经典论文。该论述中强调由于软体的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。 概念本意是指万金油、万能药、一个完美的解决方案。在软件开发中，银弹是指使得使生产率、可靠性或简洁性获得数量级上的进步。但是软件开发本身具备复杂性，不可见性，可变性，随着计算机历史的发展，软件开发次要困难从很大程度上已经得到解决，但从某种程度上来说，无论怎么发展，软件本身具有的复杂性都没有从根本上得到解决。 转自：https://www.zhihu.com/question/20829469 https://www.zhihu.com/question/20829469/answer/16319016 Shim VS polyfill概念 shim shim一般指一些做兼容性的库,用来弥补旧浏览器对新特性支持的不足。它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现，即把不同API封装成一种。 polyfill 一个polyfill就是一个用在浏览器API上的shim，也是·对浏览器的不足做补充。但是它的做法是先检查当前浏览器是否支持某个API,如果不支持的话就加载对应的polyfill.然后新旧浏览器就都可以使用这个API了 示例：旧浏览器不支持 ES6 的 Array.prototype.find 方法,我们想要在项目中使用Array.prototype.find, Shim：function arrayFind() { if (Array.prototype.find) {// … } else {// … }} Polyfill：if (!Array.prototype.find) { Array.prototype.find = function() {// …}} 转自：https://www.jianshu.com/p/26d34cebf6be?utm_source=oschina-app 库 (library) VS 框架(framework)概念1、库 库是一系列预先定义好的数据结构和函数(对于面向对象语言来说，是类)的集合，提供给开发者使用，程序员通过使用这些数据结构和函数实现功能。库没有控制权，控制权在使用者手中，在库中查询需要的功能在自己的应用中使用。 2、框架 框架也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，会基于自身的特点向用户提供一套相当于叫完整的解决方案，而且控制权的在框架本身，使用者要找框架所规定的某种规范进行开发。 本质区别 框架与库之间最本质区别在于控制权：you call libs, frameworks call you（控制反转） 联系和区别二者联系紧密，他们以聚合的形式让我们在所要开发的应用中使用，在框架中我们完全可以自由的使用库，同时也可以没有框架的基础之上使用库，使用库的控制权始终在我们的手中，但是使用框架时候就必须按照它的规范来进行模块化的开发。 图6 库和框架的关系 图7 应用、库和框架的关系 转自：https://www.jianshu.com/p/60100985dd7f 方法(method ) VS 函数(function)函数属于整个文件, 方法属于某一个对象，函数可以直接调用,方法必须用对象或者类来调用 URL VS URI VS URN概念1、URI：Uniform Resource Identifier，统一资源标识符 URI是以某种统一的（标准化的）方式标识资源的简单字符串，一般由三部分组成： （1）访问资源的命名机制。 （2）存放资源的主机名。 （3）资源自身的名称，由路径表示 2、URL：Uniform Resource Locator，统一资源定位符 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL的格式由下列三部分组成： （1）协议（或称为服务方式）； （2）存有该资源的主机IP地址（有时也包括端口号）； （3）主机资源的具体地址。如目录和文件名等。 第一部分和第二部分之间用”：//”符号隔开，第二部分和第三部分用”/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 URN：Uniform Resource Name，统一资源名称 URN是用特定命名空间的名字标识资源 联系和区别 联系 URL和URN都是URI的一种，URI的范畴位于体系的顶层，URL和URN的范畴位于体系的底层。这种排列显示URL和URN都是URI的子范畴。 图8 三者的关系 不同 URI 指的是一个资源,URL是用地址定位一个资源，URN是用名称定位一个资源 转自：https://www.cnblogs.com/wxlzhizu/archive/2010/06/04/1751517.html localStorage VS sessionStorage概念localStorage和sessionStorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现） 异同点 相同点 存储大小都是5MB 都保存在客户端，不与服务端交互通信 只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理 不同点 生命周期不同 localStorage生命周期是永久，关闭页面或浏览器之后localStorage存储的数据也不会丢失，除非用户显式地在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了 数据共享机制 不同浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口） 不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 转自：https://www.cnblogs.com/vickylinj/p/10883256.html 向前兼容(Foreward Compatibility) VS 向后兼容(Backward Compatibility)概念 兼容包括：硬件兼容性和软件兼容性 Forward意思是向前进，指未来，向前兼容是站在旧版本的立场讨论未来版本的兼容性问题。在计算机中指在较低档计算机上编写的程序，可以在同一系列的较高档计算机上运行，或者在某一平台的较低版本环境中编写的程序可以在较高版本的环境中运行，都称为向上兼容，前者是硬件兼容，而后者是软件兼容。向上兼容具有非常重要的意义，一些大型软件的开发，工作量极大，如这些软件都能做到兼容，则无需在其它机器上重新开发，就可节省庞大的人力和物力。 Backward意思是向后退，指过去，站在新版本的立场讨论过去版本的兼容性问题。在计算机中指在一个程序或者类库更新到较新的版本后，旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。例如较高档的计算机或较高版本的软件平台可以运行较为低档计算机或早期的软件平台所开发的程序。向下兼容可以使用户在进行软件或硬件升级时，厂商不必为新设备或新平台从头开始编制应用程序，以前的程序在新的环境中任然有效。 转自：https://blog.csdn.net/wangxufa/java/article/details/72846362 正向代理(Forward proxy) VS 反向代理(Reverse proxy) 网络代理分为正向代理和反向代理。 正向代理（1）概念 当客户端无法访问外部资源的时候，可以通过一个正向代理去间接地访问，所以客户端需要配置代理服务器的ip。 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 图9 正向代理 （2）举例 我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 图10 反向代理 作用 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理 概念 反向代理实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。客户端是感知不到代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 作用 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理服务器来优化网站的负载 转自：https://www.jianshu.com/p/a1c35f5d27f7 ES6 VS ES2015ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript是Netscape创造的并交给了国际标准化组织ECMA，之所以不叫做JavaScript由于商标的问题，java是sun公司的商标，根据授权协议只有Netscape公司可以合法使用JavaScript这个名字，另外就是为了体现JavaScript的标准的制定者不是ECMA所以取名为ECMAScript ECMAScript 的历史ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学 3.0 版的语法。 2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6继承了。因此，ES6 制定的起点其实是 2000 年。 为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。2008 年 7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 ES6 与 ECMAScript 2015 的关系ES6是ECMA的为JavaScript制定的第6个版本的标准，标准委员会最终决定，标准在每年的 6月份正式发布一次，作为当年的正式版本。ECMAscript 2015是在2015年6月份发布的ES6的第一个版本。依次类推ECMAscript 2016 是ES7、 ECMAscript2017 是ES8……，最新的是ECMAscript 2019，即ES10 转自：https://es6.ruanyifeng.com/#docs/intro 进程(process) VS 线程(thread)进程和线程是操作系统的基本概念 概念进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 从CPU运行的角度理解CPU+RAM+各种资源（比如显卡，光驱，键盘等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。 执行一段程序代码，实现一个功能的过程是：当得到CPU的时候，相关的资源必须也已经就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次得到CPU。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他得到CPU的运行环境，必须保存。 所以计算机工作的过程是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。 进程和线程就是这样的背景出来的，两个名词是对应的CPU时间段的描述。进程就是包换上下文切换的程序执行时间总和，即CPU加载上下文、CPU执行、CPU保存上下文之和。进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU，然后CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。 二者关系（1）根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 （2）资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 （3）包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 （4）内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 （5）影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 （6）执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 转自：https://blog.csdn.net/ThinkWon/java/article/details/102021274 https://blog.csdn.net/ThinkWon/article/details/102021274 参考：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 形参（parameter） VS 实参 (argument)概念1、实参 全称为”实际参数”，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等 2、形参 全称为”形式参数”由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数 VR（Virtual Reality）VS AR（Augmented Reality） VS MR（Mixed Reality）概念1、VR（虚拟现实） 是指利用计算机技术模拟产生一个为用户提供视觉、听觉、触觉等感官模拟的三度空间虚拟世界，用户借助特殊的输入/输出设备，与虚拟世界进行自然的交互。用户进行位置移动时，电脑可以通过运算，将精确的三维世界视频传回产生临场感，令用户及时、无限制地观察该空间内的事物，如身临其境一般。 简单地说，VR看到的图像全是计算机模拟出来的，都是虚假的 2、AR（增强现实） 是一种实时计算摄影机影像位置及角度，并辅以相应图像的技术。这种技术可以通过全息投影，在镜片的显示屏幕中将虚拟世界与现实世界叠加，操作者可以通过设备互动。 AR是将虚拟信息加在真实环境中，来增强真实环境，因此看到的图像是半真半假，如Faceu激萌特效相机APP，这款APP会自动识别人脸，并在人脸上叠加动态贴图和道具，从而创造出卖萌搞笑效果的照片，例如加兔子耳朵、加彩虹特效 3、MR（混合现实） 指的是结合真实和虚拟世界创造了新的环境和可视化三维世界，物理实体和数字对象共存、并实时相互作用，以用来模拟真实物体，是虚拟现实技术的进一步发展。 MR是将真实世界和虚拟世界混合在一起，可以说它呈现的图像令人真假难辨 三者关系VR概念最小，AR概念包含了VR，MR概念最大，包含了VR和AR AR和MR的辨别虚拟物体与真实物体是不是被肉眼分离出来，如果不能被肉眼分离的就是MR，可以的就是AR。例如之前提到的Faceu激萌特效相机APP以及不少AR应用一眼就可以知道哪些是真的，哪些是假的。而MR直接向视网膜投射整个4维光场，所以用户看到的物体和看真实的物体，从数学上是没有区别的。 转自：https://www.sohu.com/a/203516748_100033040 yarn VS npm二者都是JS依赖包管理工具，Yarn 是由 Facebook，google，Exponent 和 Tilde制作的一种新的JavaScript 软件包管理器。可以在官方公告上看到，其目的是解决团队在npm 面临的问题，即安装包不够快、有安全隐患，npm 允许安装包执行代码。 npm的问题 npm install的时候非常慢，删除node_modules，重新install的时候依旧如此； 同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 图11 npm版本控制 “5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就会导致同一个项目，由于安装的版本不一致出现bug。 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，使得不太容易注意到实际发生的错误。 yarn的优点1、速度快，速度快主要来自以下两个方面： （1）并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm是按照队列执行每个 package，也就是说必须要等到当前 package安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 （2）离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 2、安装版本统一 为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file)记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn就会创建（或更新）yarn.lock这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 3、更简洁的输出 npm 的输出信息比较冗长。在执行 npm install &lt;package&gt;的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn简洁太多：默认情况下，结合了emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 转自：https://www.jianshu.com/p/254794d5e741 K VS P（Progressive）我们在下载电影时，通常有标清、高清、全高清甚至超高清的源，再细心一点我们会发现它们分别又叫480p、720p、1080p…，那么这些数字背后意味着什么，K和p又分别代表什么含义？ 概念 P是Progressive,逐行的意思，P是逐行扫描，表示的是“视频像素的总行数”，几P就是纵向有多少行像素，例如，1080p就是纵向有1080行像素，1080x1080（1:1），1440x1080（1.33），1920x1080（1.78），2581x1080（2.39），3840x1080（3.56）等都是1080P K表示的是“视频像素的总列数”，“几K”的原始定义是：横向大约有几个1024列像素，1K就是1024，2K就是2048，4K就是4096，以此类推。但在电视领域，这些“几K”都被加上了一个固定分辨率标准，比如2K是2560x1440，4K是3840x2160，大家平时所说的这些所谓标准，都是16：9的电视标准（TVStandard） K”和“P”能否同时出现？要想准确描述一个屏幕或视频的分辨率，这两者必须同时出现，否则就会出现歧义 电视标准仅仅只在电视领域或日常生活中16:9的视频和显示器比例中适用，一旦脱离了电视领域，或者屏幕及视频比例不再是16：9，该规则即作废，定义一个视频有几K的方法只有一个：横向像素数有几个1024，定义一个视频有几P的方法也只有一个：纵向有多少行像素 4K（超高清）、1080P（全高清）、720P（超清）、480P（高清） 转自：https://www.bilibili.com/read/cv2889564/","link":"/2020/05/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"TypeScript编码规范","text":"1.命名及约定1.1类使用PascalCase进行命名。 Bad 1class foo { } Good 1class Foo { } 1.2类成员（变量、方法）使用camelCase进行命名。 Bad 1234class Foo { Bar: number; Baz(): number { }} Good 1234class Foo { bar: number; baz(): number { }} 1.3接口使用PascalCase进行命名，不要在接口名前加“I”。 接口成员使用camelCase进行命名。 Bad 1234interface IFoo { Bar: number; Baz(): number;} Good 1234interface Foo { bar: number; baz(): number;} 1.4命名空间使用PascalCase进行命名。 Bad 12namespace foo {} Good 12namespace Foo {} 1.5枚举 使用PascalCase进行命名。 Bad 12enum color {} Good 12enum Color {} 枚举成员使用PascalCase进行命名。 Bad 123enum Color { red} Good 123enum Color { Red} 1.6文件名 使用破折号分隔描述性单词，比如：hero-list.ts。 使用点将描述性名称与类型分开，比如：user-info.page.ts 尽量使用常规的几种类型名，包括.page,.service,.component,.pipe,.module,.directive,.controller和.middleware。当然也可以自己创建其他类型，但不宜太多。 类名与文件名匹配，并遵循类命名规范。 类名 文件名 export class AppComponent { } app.component.ts export class HeroListComponent { } hero-list.component.ts export class UserProfileService { } user-profile.service.ts 2.类型 需显式地为变量、数组和方法编写类型（类型推论能够推断出类型的不需要声明类型）。 Bad 1234567891011121314class Bar { bar(input) { let isZero; const foo: number = 5; if(input===5){ isZero=false; } const resultObject = { fo: foo, isZeroRes: isZero }; return resultObject; }} Good 12345678910111213141516171819class Bar { bar(input: number): BarResult { let isZero: boolean; const foo = 5; if (input === 0) { isZero = true; } const resultObject = { fo: foo, isZeroRes: isZero }; return resultObject; }}interface BarResult { fo: number; isZeroRes: boolean;} 不要使用Number、String、Boolean、Object为变量、数组和方法设置类型。 Bad 123baz(foo: String): String {} Good 123baz(foo: string): string {} 3.声明变量 如果变量在其生命周期可能发生改变，尽量使用let。 如果一个值在程序生命周期内不会改变，尽量使用const。 Bad 123456var bar = 'bar';var count;if (true) { console.log(bar); count += 1} Good 123456const bar = 'bar';let count: number;if (true) { console.log(bar); count += 1;} 4.对象 使用{}进行对象创建。 bad 1const item = new Object（）; Good 1const item = {}; 在对象字面量里使用属性简写。 Bad 1234const lukeSkywalker = 'Luke Skywalker';const obj = { lukeSkywalker: lukeSkywalker,}; Good 1234const lukeSkywalker = 'Luke Skywalker';const obj = { lukeSkywalker,}; 仅使用引号用于属于无效标识符的属性。 Bad 12345const bad = { 'foo': 3, 'bar': 4, 'data-blah': 5, }; Good 12345const good = { foo: 3, bar: 4, 'data-blah': 5, }; 5.字符串 使用单引号声明字符串。 Bad 1const bar = \"bar\"; Good 1const bar = 'bar'； 6.解构 访问和使用对象的多个属性时，使用对象解构。 Bad 12const foo = user.firstName;const bar = user.lastName; Good 1const { foo, bar } = user; 访问数组中的多个数据时，使用解构。 Bad 123const arr = [1, 2, 3, 4];const first = arr[0];const second = arr[1]; Good 12const arr = [1, 2, 3, 4];const [first, second] = arr; 7.空格 在定义类型前面加上空格。 赋值等号两边加上空格。 方法、类大括号前空格。 对象冒号后空格。 Bad 12345678910class Foo{ openDetail(item:string):void{ let foo:string; foo=''; const foa={ name:'foo' }; console.log(item); }} Good 12345678910class Foo { openDetail(item: string): void { let foo: string; foo = ''; const foa = { name: 'foo' }; console.log(item); }} 8.缩进使用两个空格缩进。 9.分号语句结尾添加分号。 Bad 1const foo = 'foo' Good 1const foo = 'foo'; 10.数组 使用[]定义数组。 Bad 1let foos:Array&lt;Foo&gt;; Good 1let foos:Foo[]; 使用push添加数据 Bad 12const foos = [];foos[foos.length] = 'abracadabra'; Good 12const foos = [];foos.push('abracadabra');","link":"/2020/05/24/TypeScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"JavaScript模块化","text":"模块化的理解1、什么是模块化 将一个复杂的程序，依据一定的规则(规范)封装成一个或多个块(文件), 并进行组合在一起。 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。 2、模块化的进化过程无模块时代 在ajax还未提出之前，js还只是用来在网页上进行表单校验、提交，对DOM渲染操作。 123456789101112131415161718var str,num;//......function submit(){ str = document.getElementById(\"xx\").value; if(str){ //...... } else{ //...... } num = 1; for(var i=0; i&lt;10; i++){ num++ //...... } //...... form.submit()} 1234&lt;script type=\"text/javascript\" src=\"a.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"b.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"c.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; 缺点： 全局变量污染 函数命名冲突 文件依赖顺序 模块雏形时代 2006年，ajax的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，传统的网页向“富客户端”发展，出现了简单的功能对象封装。 namespace模式 12345678//模块jsvar myModule = { first_name: 'www.', second_name: 'baidu.com', getFullName: function() { return this.first_name + this.second_name; }} 1234//调用jsconsole.log(myModule.getFullName());myModule.first_name = 'img.';console.log(myModule.getFullName()); 优点: 减少了全局变量，解决命名冲突缺点: 数据不安全(外部可以直接修改模块内部的数据)，模块名称会暴露在全局，存在命名冲突，依赖顺序问题 自执行匿名函数（闭包）模式 1234567891011//模块js(function (window) { let _moduleName = 'module'; function setModuleName(name) { _moduleName = name; } function getModuleName() { return _moduleName; } window.moduleA = { setModuleName, getModuleName }})(window) 1234//调用jsmoduleA.setModuleName('html-module');console.log(moduleA.getModuleName());console.log(moduleA._moduleName);//模块不暴露，无法访问模块内属性方法 优点：变量、方法全局隐藏，模块私有化缺点：模块名称会暴露在全局，存在命名冲突，依赖顺序问题 3、面临的问题从以上的尝试中，可以归纳出js模块化需要解决那些问题： 如何安全的包装一个模块的代码？（不污染模块外的任何代码） 如何唯一标识一个模块？ 如何优雅的把模块的API暴漏出去？（不能增加全局变量） 如何方便的使用所依赖的模块？ 模块化的规范1、CommonJS2009年Nodejs发布，采用 CommonJS 模块规范。 特点： 每个文件都是一个模块实例，代码运行在模块作用域，不会污染全局作用域。 文件内通过require对象引入指定模块，通过exports对象来向往暴漏API，文件内定义的变量、函数，都是私有的，对其他文件不可见。 每个模块加载一次之后就会被缓存。 所有文件加载均是同步完成，加载的顺序，按照其在代码中出现的顺序。 模块输出的是一个值的拷贝，模块内部的变化不会影响该值。 123456789//模块jslet _moduleName = 'module';function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName ;}module.exports = { setModuleName, getModuleName } 1234//调用jsimport { getModuleName, setModuleName } from './es6.module';setModuleName(\"es6 Module\");console.log(getModuleName()); 缺点：模块同步加载，资源消耗和等待时间，适用于服务器编程 2、AMD/RequireJSCommonjs局限性很明显： 基于Node原生api在服务端可以实现模块同步加载，但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个在客户端上基于Commonjs但是对于加载模块做改进的方案，于是AMD规范诞生了。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（依赖前置），这个回调函数才会运行。 RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法将代码定义为模块，通过require方法实现代码的模块加载。 12345678// module1.js 定义没有依赖的模块define(function () { let _moduleName = 'module'; function getName() { return _moduleName; } return { getName } // 暴露模块}) 123456789101112// module2.js 定义有依赖的模块define(['module1'], function (module1) { let _firstName = 'AMD' function getFullName() { return _firstName + ' ' + module1.getName(); } function setFirstName(name) { _firstName = name; } // 暴露模块 return { _firstName, getFullName, setFirstName }}) 12345678910111213141516//mian.jsrequire.config({ paths: { module1: './modules/module1', module2: './modules/module2', // 第三方库模块 jquery: './libs/jquery.min' }})require(['module2','jquery'], function(module2,jquery) { console.log(module2.getFullName()); module2.setFirstName('AMD-AMD'); console.log(module2.getFullName()); console.log(module2._firstName); jquery('#moduleId').html(\"&lt;i&gt;My name is jquery-module&lt;/i&gt;\");}) 12//html中引入工具库，并定义js主文件&lt;script data-main=\"./main\" src=\"./libs/require.js\"&gt;&lt;/script&gt; 特点：浏览器直接运行无需编译，异步加载，依赖关系清晰 3、CMD/SeaJSCMD规范专门用于浏览器端，同样是受到Commonjs的启发，国内（阿里）诞生了一个CMD（Common Module Definition）规范。该规范借鉴了Commonjs的规范与AMD规范，在两者基础上做了改进。 与AMD相比非常类似，CMD规范（2011）具有以下特点： define定义模块，require加载模块，exports暴露变量。 不同于AMD的依赖前置，CMD推崇依赖就近（需要的时候再加载） 推崇api功能单一，一个模块干一件事。 SeaJs是CMD规范的实现，跟RequireJs类似，CMD是SeaJs推广过程中诞生的规范。CMD借鉴了很多AMD和Commonjs优点。 123456//module.1define(function (require, exports, module) { module.exports = { msg: 'I am module1' }}) 12345678//module.2define(function (require, exports, module) { var module2 = require('./module1') function show() { console.log('同步引入依赖模块1 ' + module2.msg) } exports.showModule = show}) 12345//main.jsdefine(function (require) { var m2 = require('./modules/module2') m2.showModule();}) 12345//html中引入工具库，并定义js主文件&lt;script type=\"text/javascript\" src=\"./libs/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.use('./main')&lt;/script&gt; AMD、CMD区别 AMD 推崇依赖前置 CMD 推崇依赖就近 12345678//AMDdefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好 a.doSomething() ... // 此处略去 100 行 b.doSomething() ...}) 12345678910//CMDdefine(function(require, exports, module) { var a = require('./a') a.doSomething() ... // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() ...} 4、ES62015年，ES6规范中，终于将模块化纳入JavaScript标准，从此js模块化被ECMA官方扶正，也是后来js的标准。ES6中的模块化在CommonJS的基础上有所不同，关键字有import，export，default，as，from。 123456789//模块jslet _moduleName = 'module';function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName;}export { setModuleName, getModuleName } 1234//调用jsimport { getModuleName,setModuleName } from './es6.module';setModuleName(\"es6 Module\");console.log(getModuleName()); CommonJS和ES6区别 CommonJS 模块输出的是一个值的拷贝，即原来模块中的值改变不会影响已经加载的该值。ES6 模块输出的是值的只读引用，模块内值改变，引用也改变。 CommonJS 模块是运行时加载，加载的是整个模块，即将所有的接口全部加载进来。ES6 模块是编译时输出接口，可以单独加载其中的某个接口。 总结 CommonJS规范主要用于服务端编程，加载模块是同步的，不适合在浏览器环境，存在阻塞加载，浏览器资源是异步加载的，因此有了AMD、CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，代码更简单。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。","link":"/2020/05/29/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"Rap2入门","text":"写在最前面是什么？是阿里妈妈前端团队出品，是一个接口可视化管理平台。 使用了Mock.js作为Mock引擎，用于前后端分离的开发模式中，根据约定接口自动生成模拟数据。 能解决什么问题 前端独立开发，不受后端接口开发进度的影响 无需前后端联调，避免频繁沟通，减少双方时间成本 支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等模拟数据，可实现真实接口请求效果 最终目的提升协作效率，少加班，少熬夜 快速上手登录打开Rap2官方服务站点rap2.taobao.org之后进行登录，新用户需要注册。 说明：rap2为开源项目，也可以通过下载官方源码，自行编译本地部署。rap2源码传送门注意：公司内部用户请使用内部服务，数据进行了定期备份，更安全，更可靠。内部地址：http://xxx.xx.xxx.108:8887/ths-rap2，地址全路径请咨询组内人员 新建仓库一般一个项目建立一个仓库，仓库中存放这个项目的所有接口。按照以下步骤进行操作: 操作说明： 新建仓库：发起仓库新建操作 仓库名称（必填）：建议与项目名称保持一致 简介（非必填）：对仓库名称进行补充描述 成员（非必填）：被添加的成员可以获得这个仓库内接口的操作权限，一般为这个项目的前后端开发人员 团队（非必填）：被添加的团队，团队内成员可以获得这个仓库内接口的操作权限 协同仓库ID（非必填）：在当前仓库中无法匹配到接口时，将会从协同仓库中寻找，便于大的项目按不同仓库拆分管理 新建模块一般仓库下可以按照功能划分出来多个模块，每个模块放对应的接口，方便接口查找。按照以下步骤进行操作: 操作说明： 新建模块：发起模块新建操作 模块名称（必填）：这里的模块名称，可以按照功能划分 模块简介（非必填）：对模块名称进行补充描述 新建接口按照以下步骤进行操作: 操作说明： 新建接口：发起接口新建操作 名称（必填）：接口文本描述 地址（必填）：接口的访问地址 类型：请求类型 请求码：http状态码 简介：对名称的补充描述 设置请求参数&amp;响应结果请求参数示例数据JSON： 1234567891011121314{ \"token\": \"\", \"login_name\": \"\", \"code_region\": \"\", \"trade_code\": \"\", \"sync_nation\": \"\", \"code_land\": \"\", \"scflag\": \"\", \"longitude_d\": \"\", \"latitude_d\": \"\", \"pageSize\": \"\", \"pageMum\": \"\", \"\": \"\"} 按照以上操作进入接口编辑状态 进入编辑状态后操作说明： 这个区域可以设置请求头，参数传输方式。这两个都需要提前跟后端沟通好 导入：该操作可以根据提前跟后端沟通定义好的JSON格式对象进行参数的快速导入注意：也可以通过单行方式导入，具体参照下图 响应参数示例数据JSON： 1234567891011121314151617181920{ \"data\": [ { \"LANDNAME\": \"@cword(1, 3)污染地块\", \"CODE_LAND\": \"\", \"CODE_STAGE_NAME\": \"初步调查\", \"NEW_SUPERVISETIME\": \"@now(yyyy-MM-dd)\", \"SUPERVISENUM\": \"1\", \"DISTANCE\": \"@natural(10, 1000)\", \"LONGITUDE\": \"@float(109,120)\", \"LATITUDE\": \"@float(20,30)\", \"TRADENAME\": \"采矿业\", \"REGIONNAME\": \"白云区\", \"SYNC_NATION\": \"\", \"FAVOURITE_ID\": \"\", \"CODE_STAGE\": \"SURVEP\", \"SEEMINFO_ID\": \"6f2b8060- 34a1-446f-8f80-a771df3e1a20\" } ]} 注意：所有设置完成后，记得点击右上角的保存，不然接口设置不生效 操作说明： 导入：该操作可以根据提前跟后端沟通定义好的JSON格式对象进行参数的快速导入注意：也可以通过单行方式导入。 接口访问地址 注意：由于演示地址为post 请求，必须在程序中或Postman等工具发起请求，这里只是为了获取到地址 地址说明： 基础地址：对应生成环境中的项目服务地址 接口地址：接口相对地址，定义时建议和实际接口保持一致，这样只需修改基础地址即可切换生产环境 到此为止，一个可以在程序中访问的模拟接口已经完成了 补充看到这里，大家肯定有疑问，模拟随机数据怎么模拟的呢？上边一些截图中带@符号的是什么啊？我模拟数据是个列表，现在才生成一条啊。 下面为大家讲解下，两个比较重要的东西。生成规则和初始值 生成规则和初始值这两个是配合着使用的，也可以单独设置一个。在文章刚开始，讲到rap2使用了Mock.js作为Mock引擎,所以这两个的设置是遵循Mock.js 语法规范的。 比如快速上手部分例子，我们要让列表生成10条数据，如何设置呢？我们只需要把生成规则列设置成10就行了。 我是如何知道这个设置10可以生成10条数呢？查看Mockjs官方文档示例。传送门 再比如我们还想设置地块列表中地块名称为xxx污染地块，每一条都不一样，那就需要像上边截图中那样设置初始值了。@cword(1, 3)污染地块。传送门](http://mockjs.com/examples.html#Random.cword( pool?, min?, max? ))) Mockjs示例文档与Rap2设置对应关系说明（有其他模拟数据需求，都可以查看Mockjs给出的示例）:","link":"/2020/06/01/Rap2%E5%85%A5%E9%97%A8/"},{"title":"PWA--下一代的web应用模型","text":"概述 不知道从什么时候开始，当我们在浏览网页时，页面会出现一个弹窗，询问我们是否要将此网页保存到本地，如果我们选择了确定，在设备的主屏上就会出现一个新的app，而它就是我们刚才浏览的网页。这种app我们并没有从应用商店去下载，但是我们可以像使用app一样去使用它，也可以像卸载其他app一样去将它卸载，那么这究竟是个什么东西呢，它就是这篇文章的主角——PWA。 什么是PWAPWA是Progressive Web App的简写，中文名称为渐进式web应用。它是Google 在2016年提出的概念，2017年落地的web技术，一种在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。PWA不单指一种技术，你也可以将其理解为一种思想和概念，目的就是对标原生app，将Web网站通过一系列的Web技术去优化它，提升其安全性，性能，流畅性，用户体验等各方面指标，最后达到用户就像在用app一样的感觉。 PWA为什么会出现说到app，我们就不得不提起native app即原生app，现在非常主流的移动端应用。原生app使用起来会很流畅，性能好，安全性也可以很高，这是它很显著的优势。但是缺点呢，也很明显，比如： 开发成本很昂贵 软件上线，版本更新都需要发布到不同的商店，并通过审核 这对开发人员来说是比较麻烦的事情。而对于用户来说，有些APP可能使用频率特别少，但还是不得不去商店中下载庞大的安装包，或者可能一段时间不使用以后，随着版本的更新，也不得不去重新更新并安装。 PWA则完美地避免了这些问题。 如何判断一个web应用是PWA要判断一个web应用是否是PWA，可以从以下几个方面去考虑： 可发现的—— 内容可以通过搜索引擎发现。 可安装—— 可以出现在设备的主屏幕。 可链接—— 你可以简单地通过一个URL来分享它。 独立于网络——它可以在离线状态或者是在网速很差的情况下运行。 渐进式—— 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。 可重用—— 无论何时有新的内容它都可以发送通知。 响应性—— 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。 安全—— 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。 当然，在安装方式上PWA应用与原生app有很大的不同，但是在实际使用上，与原生应用的差距非常小，对于用户来说，几乎是无感的。 核心功能Service-WorkersService Workers是浏览器和网络之间的虚拟代理，运行在一个与页面的 JavaScript 主线程独立的线程上，并且没有对 DOM 结构的任何访问权限，并且可以在不同的上下文之间发送和接收信息。 您可分配给 Service Worker 一些任务，并使用基于 Promise 的方法在任务完成时收到结果。他们不仅仅提供离线功能，还提供包括处理通知，在单独的线程上执行繁重的计算等。Service workers 非常强大，因为他们可以控制网络请求，修改网络请求，返回缓存的自定义响应，或合成响应。因为它们非常强大，所以 Service Workers 只能在安全的上下文中执行（即 HTTPS ）。 注册service worker12345678if ('serviceWorker' in navigator) { // 浏览器支持SW // Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围 navigator.serviceWorker.register('serviceWorker.js').then(function (registration) { console.log('ServiceWorker注册成功: ', registration.scope); }).catch(function (err) { console.log('ServiceWorker注册失败: ', err); }); } 注册完成后，serviceWorker.js 文件会自动下载，然后安装，最后激活。 service worker中的常用事件 install 123456789101112131415161718var cacheName = 'hello-pwa';// install 事件，它发生在浏览器安装并注册 Service Worker 时 self.addEventListener('install', event =&gt; { // event.waitUtil 用于在安装成功之前执行一些预装逻辑,但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率,安装成功后 ServiceWorker 状态会从 installing 变为 installed event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll( [ '/', // 这个一定要包含整个目录，不然无法离线浏览 './images/cat2.jpg', './index.html', './style.css' ] // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 )).then(() =&gt; self.skipWaiting()) );}); service worker会等到 waitUntil 里面的代码执行完毕之后才开始安装，它返回一个promise。caches 是一个特殊的 CacheStorage 对象，它能在Service Worker指定的范围内提供数据存储的能力。 fetch 每次当我们的应用发起一个http请求时，我们还有一个fetch 事件可以使用。这个事件对我们来说非常有用，它允许我们拦截请求并对请求作出自定义的响应。 1234567891011121314// 为 fetch 事件添加一个事件监听器,service worker将从缓存中请求所需的数据，从而提供离线应用功能self.addEventListener('fetch', function (e) { event.respondWith( // 使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容，如果存在的话，返回缓存的资源；如果资源并不存在于缓存当中，通过网络来获取资源，并将资源存储到缓存中。 caches.match(e.request).then(function (r) { return r || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }) );}); Manifest为了成为可安装网站，需要下列事情就位： 一份网页清单，填好正确的字段 网站的域必须是安全（HTTPS）的 一个本设备上代表应用的图标 一个注册好的service worker，可以让应用离线工作（这仅对于安卓设备上的Chrome浏览器是必需的） 清单文件清单文件通常位于网页应用的根目录，包含一些有用的信息，比如应用的标题，在一个移动OS上显示的代表该应用的不同大小的图标（例如，主屏图标）的路径，和用于加载或启动画面的背景颜色。这些信息是浏览器在安装web应用时和在主屏上显示应用需要的，这些信息是以JSON的形式列出来的。 12345678910111213141516171819202122232425262728{ \"name\": \"Minimal PWA\", //网站应用的全名 \"short_name\": \"PWA Demo\", // 显示在主屏上的短名 \"description\": \"The app that helps you understand PWA\", //一两句话解释你的应用的用途 \"display\": \"standalone\", // 应用的显示方式：可以是全屏，独立，最小ui或者浏览器 \"start_url\": \"/\", //应用启动的index文档 \"theme_color\": \"#313131\", // ui的主题色，这是操作系统使用的 \"background_color\": \"#313131\", // 背景色，用于安装程序时和启动应用时 \"icons\": [ { \"src\": \"icon/lowres.webp\", \"sizes\": \"48x48\", \"type\": \"image/webp\" }, { \"src\": \"icon/lowres\", \"sizes\": \"48x48\" }, { \"src\": \"icon/hd_hi.ico\", \"sizes\": \"72x72 96x96 128x128 256x256\" }, { \"src\": \"icon/hd_hi.svg\", \"sizes\": \"72x72\" } ] //一串图标信息——源URL,大小和类型，确保包含一些图标，这样有一个最适合用户设备的图标可以被选中} 一份网页清单最少需要name和一个图标 (带有 src, size 和 type)。description, short_name, 和start_url最好要提供。 扩展以下，过去有一些常用的扩展名用于清单：manifest.webapp 在Firefox OS应用清单中很流行，许多人使用manifest.json作为网页清单因为内容是JSON格式的。但是，.webmanifest 扩展名是在W3C清单规范中显示指定的，建议使用清单文件使用.webmanifest作为后缀 。 添加到主屏“添加到主屏”是移动浏览器实现的一个特性，它利用网页清单中的信息来在设备主屏上显示应用图标和文字。当用户使用一个支持的移动浏览器访问一个PWA时，会显示一个弹框表示可以安装这个应用，用户确认之后应用就被安装到主屏了，用户可以立刻启动并使用应用。在一些浏览器中，可以通过清单信息产生一个启动画面，当PWA启动时显示，图标、主题和背景色用于创建这个启动画面。 在ios上和android手机上打开vue的官网，可以将其添加到设备主屏： ios android Push&amp;NotificationPush&amp;Notification即推送和通知，通过推送API和通知API来实现。 推送可以实现从服务端推送新的内容而不需要客户端发起请求，它是由应用的service worker来实现的。通知功能则可以通过service worker来向用户展示一些新的信息，或者至少提醒用户应用已经更新了某些功能。 这些工作是在浏览器外部实现的，跟service worker一样，所以即使应用被隐藏到后台甚至应用已经被关闭了，我们仍然能够推送更新或者推送通知给用户。 推送API和通知API可以独立工作，也可以结合到一起使用。 通知API——请求授权当用户确定接收通知，我们的应用就可以获得推送通知的功能。用户的授权的结果有三种，default，granted 或者denied，当用户没有做出选择的时候，授权结果会返回defalut，另外两种结果分别是用户选择了授权或者拒绝授权。一旦用户选择授权，这个授权结果对通知API和推送API两者都有效。 1234567891011var button = document.getElementById(\"notifications\");console.log(button);button.addEventListener('click', function (e) { Notification.requestPermission().then(function (result) { if (result === 'granted') { // randomNotification(); console.log('授权'); } });}); 推送推送比通知要复杂一些，我们需要从服务端订阅一个服务，之后服务端会推送数据到客户端应用。应用的Service Worker将会接收到从服务端推送的数据，这些数据可以用来做通知推送，或者实现其他的需求，这个技术还处在非常初级的阶段。为了接收到推送的消息，你需要有一个service worker，在service worker 内部，存在一个消息推送服务订阅机制。 1registration.pushManager.getSubscription() .then( /* ... */ ); 一旦用户订阅服务，他们就能接收到服务器推送的通知。为了能够接收到推送的消息，我们需要在Service Worker文件里面监听push事件。 1self.addEventListener('push', function(e) { /* ... */ }); 这个技术还处在非常初级的阶段，从服务端的角度来看，出于安全的目的，这整个过程必须使用非对称加密技术进行加密。而VAPID可以为你的应用提供一层额外的安全保护。 发展趋势既然谈到PWA的发展趋势，就不得不说说它的优势和劣势了。 优势 无需安装，无需下载，只要你输入网址访问一次，然后将其添加到设备桌面就可以持续使用。 发布不需要提交到app商店审核，更新迭代版本不需要审核 现有的web网页都能通过改进成为PWA， 能很快的转型，上线，实现业务、获取流量 不需要开发Android和IOS两套不同的版本 劣势 浏览器对技术支持还不够全面， 不是每一款游览器都能100%的支持所有PWA 需要通过第三方库才能调用底层硬件（如摄像头） PWA现在还没那么火，国内一些手机生产上在Android系统上做了手脚，似乎屏蔽了PWA PWA作为一个2016年才落地的新技术，经过四年的发展，基于 Chromium 的浏览器 Chrome 和 Opera 已经完全支持 PWA 了，随着 iOS 11.3 的发布，iOS正式开始支持PWA，Windows Edge 也支持PWA了。越来越多的游览器大厂，相继的对PWA做出了支持和优化，想必PWA的时代即将到来。 关于PWA，你怎么看呢？","link":"/2020/08/06/PWA-%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/"},{"title":"Vue组件开发及NPM发布（TS版）","text":"1 创建项目123npm install -g @vue/cli // 安装Vue命令行工具，最新为vue create vue-components-ts // 项目名称自取,使用TS来开发项目 2 修改项目结构 将 src 文件夹改为 examples 作为组件的示例展示 删除 src 中的 assets，components 文件夹 将 public 中的 index.html 移入 examples 文件夹后，删除 public 文件夹 在项目根目录下，新增: components 文件夹：用于存放组件源码及导出文件 types 文件夹：用于添加 TypeScript 的类型定义文件 vue.config.js：用于修改默认的构建配置 .npmignore 文件：设置要忽略发布的文件 最终项目主要结构如下： 123456789101112131415161718192021├── components│ ├── category-name // 分类名（可选，如ECharts）│ │ ├── component-name // 单个组件│ │ │ ├── index.ts // 对外提供对组件的引用│ │ │ └── component-name.vue│ └── index.ts // 所有组件的导出文件├── examples│ ├── router│ │ ├── index.ts // 各个组件示例的路由│ ├── views│ │ ├── category-name // 分类名（可选，如ECharts）│ │ │ │── component-name // 单个组件│ │ │ │ └── component-name.vue // 封装组件的示例│ ├── App.vue│ ├── index.html│ └── main.ts // 导入所有的组件├── types // 类型定义文件夹│ └── index.d.ts // 所有组件类型的导出文件├── package.json├── README.md└── vue.config.js 3 修改构建配置3.1 添加vue.config.js12345678910111213141516171819module.exports = { // 修改 src 目录 为 examples 目录 pages: { index: { // page 的入口 entry: 'examples/main.ts', // 模板来源 template: 'examples/index.html', // 在 dist/index.html 的输出 filename: 'index.html', }, }, // 扩展 webpack 配置 chainWebpack: (config) =&gt; { // 没有任何具名导出并直接暴露默认导出 config.output .libraryExport('default'); },}; 3.2 修改package.json123456789101112131415name: 包名，该名不能和NPM中已有的名称冲突；version: 版本号，不能和当前包的历史版本号相同；description: 简介；keyword：关键字，以空格分割，方便别人搜索到本模块author：作者；private：是否私有，需要修改为 false 才能发布到 npm；license：开源协议main: 入口文件，应指向编译后的包文件； 123456789101112131415{ \"name\": \"ths-vue\", \"version\": \"0.2.5\", \"private\": false, \"description\": \"基于Vue的业务组件库\", \"main\": \"./dist/ths-vue.umd.min.js\", \"author\": \"ths-fe &lt;zapzqc@qq.com&gt;\", \"license\": \"MIT\", \"keyword\": [ \"ths\", \"vue\", \"components\" ], \"typings\": \"types/index.d.ts\",} 在scripts中添加： 123456&quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;lib&quot;: &quot;vue-cli-service build --target lib --name ths-vue ./components/index.ts&quot;}, –-target : 构建目标，默认为应用模式这里修改为 lib 启用库模式 –name : 输出文件名称 –-dest : 输出目录，默认 dist，这里没有设置 3.3 修改.npmignore1234567891011121314151617# 忽略目录examples/examples/node_modules/# 忽略指定文件*.map.browserslistrc.editorconfig.eslintrc.jsbabel.config.jspackage-lock.jsontsconfig.jsonyarn.lockvue.config.js# 编辑器缓存文件.idea.vscode 4 构建并发布*4.1 构建生成组件库： 1npm run lib 实现对 examples 中应用的访问： 1npm run serve 4.2 发布首先需要在 npm 官网上注册一个账号，通过: 1npm adduser 命令创建一个账户，或者在 npm 官网注册。 注册完成后在本地命令行中登录： 1npm login 输入用户名、密码、邮箱： 执行发布命令，发布到 npm： 1npm publish 如果以前改过 npm 的镜像地址，比如使用了淘宝镜像，就先改回来： 1npm config set registry http://registry.npmjs.org 5 新增组件* 在components文件夹下创建新组件命名的文件夹，其中包含新组件的单文件组件.vue和一个导出文件index.ts。 1234567import 新的组件名 from './新的单文件组件名.vue';新的组件名.install = (Vue) =&gt; { Vue.component(新的组件名.name, 新的组件名);};export default 新的组件名; 在components文件夹下的所有组件的入口文件index.js中添加 12345678// 在下方导入新增组件import 新的组件名 from './新的单文件组件名';// 存储组件列表const components = { // 在下方添加新增组件 新的组件名,}; 在types文件夹下创建新组件的d.ts文件 123import { TUIComponent } from './component';export declare class 新的组件名 extends TUIComponent { } 测试组件 在examples的main.js中导入组件，并use。 待补充 在App.vue的模板中使用： 待补充 运行： 1npm run serve 6 使用组件库*ths-vue 是基于思路前端设计理念的 Vue UI 组件库，主要用于研发企业级前端产品。 特性 提炼自企业前端产品的交互语言和视觉风格。 开箱即用的高质量 Vue 组件。 支持环境 现代浏览器和 IE9及以上（需要 polyfills） 支持服务端渲染 Electron IE/Edge Firefox Chrome Safari Opera ) Electron IE9, IE10, IE11, Edge last 2 versions last 2 versions last 2 versions last 2 versions last 2 versions 兼容性 ths-vue 支持所有的现代浏览器和 IE9+。 对于 IE系列浏览器，需要提供 es5-shim 和 es6-shim 等Polyfills 的支持。 如果你使用了babel，强烈推荐使用 babel-polyfill 和 babel-plugin-transform-runtime 来替代以上两个shim。不要同时使用 babel 和 shim 两种兼容方法。 安装使用 npm 或 yarn 安装推荐使用 npm 或 yarn的方式进行开发，不仅可在开发环境轻松调试，也可放心地在生产环境打包部署使用，享受整个生态圈和工具链带来的诸多好处。 123npm install ths-vue --saveyarn add ths-vue 如果网络环境不佳，推荐使用 cnpm。 完整引入在 main.js 引入并注册： 12345import Tvue from 'ths-vue';import 'ths-vue/dist/ths-vue.css';Vue.use(Tvue); 在组件中使用： 1234567891011&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { } } }&lt;/script&gt; 按需引入使用 babel-plugin-import，在命令行中运行： 1npm i babel-plugin-import --save-dev 修改babel.config.js： 12345678910111213presets: [ '@vue/cli-plugin-babel/preset', ],plugins: [ ['import', { libraryName: 'ths-vue', libraryDirectory: 'components', }, 'ths-vue', ], ], 在main.ts中： 123import { HelloWorld } from 'ths-vue';Vue.use(HelloWorld); 7 注意事项组件必须声明 name 属性，这个 name 就是组件的 HTML 标签。","link":"/2020/08/20/Vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8F%8ANPM%E5%8F%91%E5%B8%83%EF%BC%88TS%E7%89%88%EF%BC%89/"},{"title":"JavaScript新特性","text":"前言我这里总结了一下ES6+中，一些比较实用的新特性。我们日常开发应该尽快使用这些新特性，能极大地提高我们的开发效率。 我刚开始实习的时候，对ES6都不太怎么了解，工作后学习并渐渐运用起来，越用越爽，两个字：简洁方便高效。 提一句：只要用了babel，所有的新特性请放心大胆地用。 你得尽快用上的“新特性” 为什么加引号，因为现在这些都不是多新的特性了，ES6是2015年就出了，到现在已经5年了。 模板字符串模版字符串：用 `（反引号）标识，用 ${} 将变量括起来 old： 场景：通常我们在自定义一些echarts或者地图上添加东西时，我们常会拼接一些html代码 1var html = '&lt;div style=\"color: ' + color + ';\"&gt;' + str + '&lt;div&gt;' 传统做法需要使用大量的“”（引号）和 + 来拼接才能得到我们需要的模版 new： 1let html = `&lt;div style=\"color: ${color} ;\"&gt; ${str} &lt;div&gt;` ${} 里可以放任意的JavaScript表达式，也可以调用函数： 12345678const count = 8, price = 10;console.log(`加购一个后数量：${++count}, 总价：${count*price}`); // 加购一个后数量：9, 总价：90console.log(`输出个字符串：${'cool'}`); // 输出个字符串：coolfunction myLove() { return \"as you love!\";}console.log(`I love ${myLove()}`); // I love as you love! 需要注意的几个问题： 当需要在字符串里使用反引号的时候，需要转义； 1console.log(`模版字符串：用 \\`（反引号）标识`); 如果${}中的变量不是字符串类型，那么会按照一般的规则转化为字符串； 12const obj = {a:1, b:2};console.log(`a = ${obj}`); // a = [object Object] 模板字符串会保留所有的空格、缩进和换行； 12345let str = `I know , you know!`;console.log(str);// I know // , you know! 解决方案：使用\\解决换行符；使用+换行拼接；使用正则替换；使用变量替换； 1234567891011121314151617let str = `I know \\ , you know!`;console.log(str); // I know , you know!str = `I know ` + `, you know!`;console.log(str); // I know , you know!str = (`I know , you know!`).replace(/\\s+/gm, ' ');console.log(str); // I know , you know!const N = '';str = (`I know${ N}, you know${ N}, all we know!`);console.log(str); // I know, you know, all we know! 扩展了解： 实现原理（未验证）：通过正则匹配，替换原字符串中的变量。包括常见的{{}}, &lt;%=xx%&gt;等 12345function replace(str){ return str.replace(/\\$\\{([^}])\\}/g,function(matched,key){ return eval(key) })} 属性简写old： 一个属性名对应一个值 12345const pageNum = 0, pageSize = 10;const params = { pageNum: pageNum, pageSize: pageSize} new： 属性名和变量名保持一致，变量名尽量迎合属性名； 12345678910const pageNum = 0, pageSize = 10, password = '123123';const params = { pageNum, pageSize, password: encrypt(password) // 属性简写和键值对可以混写}// const params = {// pageNum: pageNum,// pageSize: pageSize// } question： 如果我们的需要的值不是一个单独变量，而是从某个对象取出属性 123456const pageNum = 0, pageSize = 10, user = {uid: 100000, password: '123123'};const params = { pageNum, pageSize, user.password ????} 答案：见 4.答案 方法属性old： 一个属性名对应一个值 12345let math = { add: function(a,b) { return a + b; }, sub: function(a,b) { return a - b; }, multiply: function(a,b) { return a * b; }} new： 自动识别方法名称作为属性名 12345let math = { add(a,b) { return a + b; }, sub(a,b) { return a - b; }, multiply(a,b) { return a * b; }} 取函数名为属性名称 微信小程序page结构： 1234567891011121314151617Page({ data: { isShowloading: true }, onLoad(options) { }, onReady() { }, handleTap(event) { }})// 给page传入一个对象，这个对象的所有函数都可以进行属性名简写 question: 下面两个表达式都正确吗？ 1234567let obj1 = { fn1(){}.bind() }let obj2 = { fn2: function(){}.bind() } 箭头函数箭头函数表达方式：=&gt;，因为像个箭头，所以叫箭头函数。 old： 123var f = function (v) { return v;}; new： 12345// 写法let f = v =&gt; v;// 完整写法let f = (v) =&gt; { return v; }; 如上，当函数只有一个形参时，=&gt;左侧可以省略()； 当函数返回值可以用一句简单表达式表示时，=&gt;右侧可以省略{}和return； 1234567let f = () =&gt; 5; // ()不可省略let sum = (num1, num2) =&gt; num1 + num2;//var sun = function(num1, num2){return num1 + num2;};this.httpUtil.get('xxxxxx.vm', params, true, res =&gt; { console.log(res)}); question: 以下会输出什么？ 12let getTempItem = () =&gt; { id: 's8309a82n', name: \"Temp\" };getTempItem(); “你懂的”运算符Spread operator，这个中文名称有好几种说法（扩展运算符、延展操作符、展开运算符等等），而我给它起的名字就叫你懂的运算符。它表示方法前面见过了...，作用是可以将数组、字符串、对象等在语法层面上展开。 秘诀：给我“解压”到这里 “解压”数组 12345678const rgb = ['red', 'green', 'blue'];const colors = [...rgb]; // 巴啦啦魔仙变，给我把rgb解压到这个数组里// 结果： ['red', 'green', 'blue']const colorList = ['yellow', ...rgb]; // ['yellow', 'red', 'green', 'blue']console.log([...colors, ...colorList]); // ???? “解压”对象 123456789let you = { name: 'DJ', age: 16}you = { ...you, school: 'DLPU'}// {name: \"DJ\", age: 16, school: \"DLPU\"} “解压”字符串 1234567let myCountry = 'China';console.log([...myCountry]); // [\"C\", \"h\", \"i\", \"n\", \"a\"]// 等同于：console.log(myCountry.split(''))cosnt resStr = {...myCountry};console.log(resStr); // {0: \"C\", 1: \"h\", 2: \"i\", 3: \"n\", 4: \"a\"}// 问题：怎么取值呢？ resStr[0] question: 以下分别会输出什么？ 123456789let obj = {a: 1, b: 2};console.log({a: 0, ...obj}); ????let arr = [2,3,4];console.log({...arr})????console.log([...obj]);???? 扩展了解：见下一章 解构赋值old: 获取对象中的值 123456789// res = {status: 200, data: {uid: 'ed9fa0', name: 'DJ', time: '1596808152'}}this.thsService.getLog().then(res=&gt;{ const status = res.status; const data = res.data; const name = res.data.name; const time = res.data.time; console.log(status, data, name, time);}) new: 123456789101112this.thsService.getLog().then(res=&gt;{ const { status, data } = res; const { status, data, data: { name, time } } = res; // console.log(status, data, name, time);})// 还可以这样写this.thsService.getLog().then({ status, data }=&gt;{ console.log(status, data);}) 数组： 123let arr = [1, 2, 3, 4];let [a, b, c] = arr; // a=1, b=2, c=3let [a, b, , d] = arr; // a=1, b=2, d=4 默认值： 12const { status = 500, data = null } = res;let [a=0, b=0, c=0, d=0, e=0] = arr; 扩展了解： 剩余运算符（ES2018） 秘诀：“剩下的”都是我的 “剩下的”属性 1234let obj = {a: 1, b: 2, c: _ =&gt; _};let {b, ...rest} = obj; // rest说：b属性你拿走吧，剩下的全是我的b // 2rest // {a: 1, c: ƒ} “剩下的”参数 12345let restParam = (p1, p2, ...p3) =&gt; { // p3说：前两个参数你们拿走，剩下的都是我的了 console.log(p1, p2, p3);};restParam(1,2,3,4,5); // p1 = 1, p2 = 2, p3 = [3, 4, 5] 数组新方法 find(): any：返回找到满足条件的第一项，否则返回undefined findIndex(): number：找到满足条件的一项的索引 includes(): boolean：是否包含一个值 在ES6之前，要判断一个数组中是否包含一个元素，是通过indexOf()返回不等于-1 ES6之后，相继扩充一些方法： find( fn(item, [index], [arr]) ): 1234let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];arr.find( item =&gt; item.id === 1 ); // { id: 1, checked: true }arr.find( item =&gt; Object.is(NaN, item) ); // NaN find会将每一个元素挨个去运行回调函数，找到了第一项之后就不会再执行了； findIndex( fn(item, [index], [arr]) ): 12arr.findIndex( item =&gt; item.id === 1 ); // 0arr.findIndex( item =&gt; Object.is(NaN, item) ); // 5 includes(value, fromIdx): 12345678arr.includes(3); // truearr.includes(NaN); // truearr.includes({ id: 2 }) // falselet a1 = {id: 2}, a2 = {id: 2};a1 == a2; // falselet a = [a1, a2]; // [{id: 2}, {id: 2}]a.includes(a2); // true 字符串同样存在includes方法：'Made in China'.includes('o'), false some( fn(item, [index], [arr]) )：是否存在满足条件的一项，和includes是同样的作用。 区别（优缺点）：some传入的是回调函数，具有更强大的可操性；includes传入参数是具体的值，书写简便。 question: find()只能取出满足条件的一项，那如何取出数组中满足条件的所有项呢？ 12let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];// ???? 扩展：数组所有方法参考手册 Promise、async/await 回调地狱：“无限”（大量）地使用嵌套回调函数，好像掉进了18层地狱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一个动画的回调地狱例子animate(ball1, 100, function () { animate(ball2, 200, function () { animate(ball3, 300, function () { animate(ball1, 200, function () { animate(ball3, 200, function () { animate(ball2, 180, function () { animate(ball2, 220, function () { animate(ball2, 200, function () { console.log(\"over\"); }) }) }) }) }) }) })});// promise优化后promiseAnimate(ball1, 500) .then(function () { return promiseAnimate(ball2, 200); }) .then(function () { return promiseAnimate(ball3, 300); }) .then(function () { return promiseAnimate(ball1, 200); }) .then(function () { return promiseAnimate(ball3, 200); }) .then(function () { return promiseAnimate(ball2, 180); }) .then(function () { return promiseAnimate(ball2, 220); }) .then(function () { return promiseAnimate(ball2, 200); })// async/await优化后async play() { await animate(ball1, 500); await animate(ball2, 200); await animate(ball3, 300); await animate(ball1, 200); await animate(ball4, 200); await animate(ball2, 180); await animate(ball2, 220); await animate(ball2, 200);} Promise: 基本用法： 12345678910111213141516171819202122232425262728293031function getUserData() { return new Promise((resolved, rejected) =&gt; { $.ajax({ type : \"get\", url : \"api.com\", success : res =&gt; { if(res.isSuccess) { resolved(res.data); }else { rejected({msg: '服务器错误', info: res.errmsg}); } }, error: err =&gt; { rejected({msg: '网络错误', info: err}); } }); })}getUserData().then(data =&gt; { console.log('success:', data);}).catch(err =&gt; { console.log(err.msg, err.info);})// 此外介绍一个方法，并行跑promise es2020有个新方法Promise.allSettledPromise.all([promise1, promise2, ...]).then(res =&gt; { console.log(res); // 由promise1,promise2正确执行结果组成的数组}).catch(err =&gt; { console.log(err);}) async/await： 是对Promise的优化，为Promise服务。一句话：用同步的风格写异步代码。 基础用法：https://patrick.js.org/post/1589841597 需要注意： async/await 就是一对“海尔兄弟”，缺一不可。async声明一个函数（函数返回会处理成一个Promise），函数里面必须要有await，await标识一个需要等一会（异步）的操作。函数内部使用了await，那么该函数就必须用async声明。 await、return和return await的陷阱：https://jakearchibald.com/2017/await-vs-return-vs-return-await/ Modules模块化是ES6比较重要的特性，在此之前JS是不支持原生的模块化的，需要通过第三方库实现如RequireJS。 了解更多模块化：JavaScript模块化 模块化由export 和 import 组成，ES6视一个文件为一个模块，文件内通过export对外暴露接口，其他文件通过import引入使用。 export：可导出变量、常量和函数 12345678910111213141516171819// utils/test.js// 单个导出export let name = 'Patrick Jun';export const pi = Math.PI;export function whoIAm() { console.log(\"I'm a FE coder!\");}// 等同于（会将export作为一个对象导出）let name = 'Patrick Jun';const pi = Math.PI;const whoIAm = () =&gt; console.log(\"I'm a FE coder!\");export { name, pi, whoIAm };// this is an object, so.export { name: name, PI: pi, iAm: whoIAm }; import：导入 123456// home.jsimport { name, pi, whoIAm } from './utils/test.js';console.log(name, pi);whoIAm();// Patrick Jun 3.141592653589793 main.js:2 // I'm a FE coder! test.js:11 node无法直接运行module：https://nodejs.org/dist/latest-v10.x/docs/api/esm.html default：只能有一个 123456789// math.jsexport function add(a,b) { return a + b; };export function sub(a,b) { return a - b; };export default (a,b) =&gt; a * b;// main.jsimport mult, { add, sub } from './math'; 你可以尝试的新特性对象新方法 Object.values(obj): 返回由对象中属性值组成的数组； Object.entries(obj): 返回对象的每个属性名和所对应的值组成的数组：[[key, value],[key, value]] 之前通过Object.keys()，可以获取到对象的所有的key，而要获得所对应的值的时候： 123456let obj = {id: 1, value: '123', data: {code: 'EC109'}};Object.keys(obj); // [\"id\", \"value\", \"data\"]Object.keys(obj).forEach((key) =&gt;{ console.log(obj[key]); // [1, \"123\", {code: 'EC109'}]}); Object.values()：无需先获取键名，直接可以拿到所有值 1Object.values(obj); // [1, \"123\", {code: 'EC109'}] Object.entries(): 123456Object.entries(obj).forEach(([key, value]) =&gt;{ console.log(key + \": \" + value);});// id: 1// value: 123// data: [object Object] **指数操作符：类似数学的书写方式进行指数计算，可以看做是Math.pow()的简写 1let a = 7 ** 3; // a = 343，等同于 a = Math.pow(7, 3) ??当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式： 12let c = a ? a : b // 方式1let c = a || b // 方式2 这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。 空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 undefined 或 null，就返回其右侧默认值。 12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b; padStart/padEnd用于在字符串开头或结尾添加填充字符串（ES2017） padStart(maxLength, [fillString])：从前面补充字符 padEnd(maxLength, [fillString])：从后面补充字符 1234567891011'es8'.padStart(2); // 'es8''es8'.padStart(5); // ' es8''es8'.padStart(6, 'woof'); // 'wooes8''es8'.padStart(14, 'wow'); // 'wowwowwowwoes8''es8'.padStart(7, '0'); // '0000es8''es8'.padEnd(2); // 'es8''es8'.padEnd(5); // 'es8 ''es8'.padEnd(6, 'woof'); // 'es8woo''es8'.padEnd(14, 'wow'); // 'es8wowwowwowwo''es8'.padEnd(7, '6'); // 'es86666' 应用场景： 1234567891011121314151617181920212223242526272829303132// 1.日期格式化const dt = new Date();console.log( `${dt.getFullYear()+''}-` +`${(dt.getMonth()+1+'').padStart(2, '0')}-` +`${(dt.getDate()+'').padStart(2, '0')}`);// 2020-08-07// 2.时间戳补位let timestamp = '1596808152';timestamp = +String(timestamp).padEnd(13, '0');// 1596808152000// 3.地区编码补位 省级编码2位，市级4位，区县6位，乡镇9位，村级12位。现在需要统一补充成12位/** * 格式化地区编码，按指定长度输出 * @param regionCode 地区编码 * @param length 需要的长度 */formateRegionCode(regionCode: string|number, length: number = 12): string { regionCode = String(regionCode); if(!regionCode || regionCode.length &lt; 2) { throw new Error('地区编码错误'); } if(length &lt; 2) { throw new Error('地区编码长度不能小于2'); } const tempCode = regionCode.split('').slice(0, length).join(''); return tempCode.length &lt; length ? tempCode.padEnd(length, '0') : tempCode;} 答案2.2 question: 123456789101112131415const pageNum = 0, pageSize = 10, user = {uid: 100000, password: '123123'};let params = { pageNum, pageSize, password: user.password // 需给定属性名，user.password是无法将其识别成属性名}// 还可以这样let params = { pageNum, pageSize, ...user // 2.5小节讲解}// {pageNum: 0, pageSize: 10, uid: 100000, password: \"123123\"}// 通过扩展符，可能会多出其他属性，如果多出来的属性对结果不影响，可以考虑这样做 2.3 question: obj1错误，obj2正确。简写方法的属性名总是变量本身作为字符串使用，bind函数本身返回一个函数，从解析器角度来说，这个返回的函数叫什么名字并没有办法确定，而第二种写法，是确定好了fn2 2.4 question: 123Uncaught SyntaxError: Unexpected token ':'let getTempItem = id =&gt; ({ id, name: \"Temp\" }); 2.5 question: 123456{a: 1, b: 2}{0: 2, 1: 3, 2: 4} // result.0 ????VM37:1 Uncaught TypeError: obj is not iterable at &lt;anonymous&gt;:1:17 2.7 question: 1arr.filter( item =&gt; item.id === 2 ); // [{id: 2}, {id: 2}] 参考资料 Modern JavaScript, 10 things you should be using, starting today - DEV 盘点ES7、ES8、ES9、ES10新特性 ES6，ES7，ES8，ES9，ES10新特性一览 ES2020新特性 种草 ES2020 新特性 异步Promise及Async/Await可能最完整入门攻略 刘哥金句：给别人讲述知识时可以发现自己掌握的是否牢固透彻，写的过程不断发现自己的不足，然后通过一些方式来解决问题，这也是一种学习过程；当然，给别人分享，也要从学习者的角度出发，考虑他们想要从你的分享中获得什么，还有就是你想表达些什么给他们。","link":"/2020/08/24/JavaScript%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"跨域解决","text":"什么导致了跨域跨域首先，网络是没有绝对安全可言的，但是，我们又需要使用浏览器来访问网络，所以浏览器能存在的安全基础就是有相对较高的安全性，提升了别人做坏事的成本。 Same-origin policy(同源策略,以下简写为 CORS)就是浏览器安全的一个重要部分。 同源策略是一个重要的安全策略，它用于限制一个源(Origin)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 同源策略的目的有两个： 对系统用户：保证用户信息的安全，防止恶意的网站窃取数据。 对开发人员：约束网站使用的资源尽可能是同源可控或者信任的资源，减少问题的可能性，从而来增强网站的安全性。 真实案例（仅限演示例子使用）：在登录腾讯文档后，打开一个文档，在控制台调用下面的代码，将会给一个好友分配该文档的编辑权限。 123456789$.ajax({ type: \"post\", url: 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1', data: 'corp_id=&amp;data=%7B%22policy%22%3A1%2C%22addmemlist%22%3A%5B%7B%22uintype%22%3A0%2C%22uin%22%3A2803621806%2C%22work_id%22%3A%22%22%2C%22info%22%3A2%2C%22new%22%3A1%7D%5D%2C%22submemlist%22%3A%5B%5D%7D&amp;message=%7B%22seq%22%3A%2272bcde05-6052-44f2-be8c-b6454a3e6716%22%2C%22action%22%3A1%7D&amp;xsrf=ac8bd23b7c50fa4b&amp;dataType=0', success: function(data) { console.log(data); }, error: function(err) {}}); 退出账号后，调用相同代码，不能给相同好友分配该文档的编辑权限。并报下面的错误。 123cgicode: 11000msg: \"no correct p_uin or p_skey or uid or uid_key in cookie [errcode:11000:0]\"retcode: 11000 由报错可以看出，出现问题是因为cookie中缺少相关信息，导致服务端认证失败。 在其他网站的控制台调用相同代码会报如下错误： 1Access to XMLHttpRequest at 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1' from origin 'https://fanyi.baidu.com' has been blocked by CORS policy: 、No 'Access-Control-Allow-Origin' header is present on the requested resource. 现在根据上面的情况试想在没有同源策略的情况下：在你登陆腾讯文档后，再打开一个其他源的网站，调用上面的代码，也是会成功给好友分配编辑权限的。进而联想到在一个第三方网站掌握腾讯文档的接口信息规则后，就可以假冒你对你的账号进行任意操作，这是十分可怕的。 那么怎么判断是同一个源呢，它的定义是什么呢？ 同源的定义：如果两个 URL的协议、主机 和 端口 (如果有指定的话) 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”。 注： 只有浏览器才会有跨域问题，因为只有浏览器才有同源策略。 恶意文档：可能导致推栈缓冲区溢出，从而在电脑中执行一些代码的文件，一般指病毒或者木马的运行程序。 跨域示例下表给出了与 URL：http://store.company.com/dir/page.html 的源进行对比的示例: URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http: 默认端口是80;https: 默认端口是443) http://news.company.com/dir/other.html 失败 主机不同 注：域名和IP指向一样，但是还是会引起跨域的。例如：http://www.ths.com.cn/和http://223.223.179.206/都指向同一个地方 限制范围随着互联网的发展，”同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制。 Cookie、LocalStorage、SessionStorage 和 IndexDB 无法读取。 脚本API访问。 AJAX 请求不能发送。 常见跨域错误缺少可跨域响应头 关键字： No ‘Access-Control-Allow-Origin’ header （Access-Control-Allow-Origin 翻译：允许访问的源）注：客户端发送的叫请求，服务器端返回的叫响应生动例子：客户端向服务器借钱是请求，服务器不给钱是对客户端的响应 允许跨域的值重复 关键字： The ‘Access-Control-Allow-Origin’ header contains multiple values ‘*, *‘, but only one is allowed。 （”允许访问的源“响应头包含重复的两个*号，但是只有一个是允许的）原因： 多次代理的时候配置的允许跨域的值有重复的。 不允许访问其他域的对象或者数据存储（cookie等） 关键字：block a frame with origin form accessing a cross-origin frame （访问了一个跨域的源） 解决跨域跨域网络访问（Cross-origin network access）因为跨域产生的原因是两个资源不在同一个域，所以有四种解决的办法： 把两个资源放到同一个域中 服务器允许资源跨域共享(CORS) 浏览器插件 利用一些不受同源策略影响的标签实现（script） 把两个资源放到同一个域中 反向代理：通过 nginx 把多个资源代理到一块 参考 nginx说明文档注： 在能操作文件的情况下，不建议多次代理，因为这样会导致网络传输变慢，影响系统的流畅性。 正向代理：通过同域的接口返回其他域的资源 注： 反向代理：访问自定义的接口来返回其他接口的资源，通过自定义接口已经不能分出真实资源来自哪里。 正向代理：由代理服务器去请求资源并返回给你，访问还是原来的真实网址。 不管是正向代理还是反向代理，都是由服务器端去进行访问的，所以要保证在服务器端能访问到真实地址。 服务器允许资源跨域共享 Tomcat 在 Tomcat根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;!-- 当指定部分可跨域时，使用下面代码配置指定域 --&gt; &lt;!-- &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; --&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注: Tomcat配置修改后必须重启Tomcat才会生效。 Nginx在 Nginx的根目录 –&gt; conf –&gt; nginx.conf 文件适当写入下述代码。 全局可跨域12345# 在 server 节点下添加以下语句add_header Access-Control-Allow-Origin *;add_header 'Access-Control-Allow-Credentials' 'true';add_header Access-Control-Allow-Methods 'GET,POST';add_header Access-Control-Allow-Headers 'Content-Type,*'; 指定接口可跨域12345678# 在指定的 location 节点下添加，示例如下：location /tomcat/ { proxy_pass http://localhost:8090/; add_header Access-Control-Allow-Origin *; add_header 'Access-Control-Allow-Credentials' 'true'; add_header Access-Control-Allow-Methods 'GET,POST'; add_header Access-Control-Allow-Headers 'Content-Type,*';} 注： Nginx配置修改后必须重启才会生效。 同时添加全局可跨域和指定接口可跨域时，访问指定接口会产生可跨域响应头重复的问题，可使用指定接口代理，因此不推荐使用全局可跨域。 注意localtion的匹配规则 当配置指定域可跨域时，可把*换为具体的域名或者IP，多个之间用逗号隔开。 多次代理设置具体相同的域也是会报允许跨域的值重复错误 多次代理设置域时，http:127.0.0.1:10229/ === http:127.0.0.1:10229 补：location和proxy_pass易混淆点 location (后面两点为URL访问的相关知识补充) location 后面带不带 / 都是一样的 如果URL的格式为http://my.suyp.com/或者http://127.0.0.1:10229/，**尾部有没有/都不会造成重定向**。因为这种情况下，浏览器请求时会在后面默认加上/。可以这样理解，没有请求是访问的http://my.suyp.com,都是访问的http://my.suyp.com/,所以没有重定向。 如果URL的格式为http:127.0.1:10229/node/。尾部如果缺少/将导致重定向。因为根据约定，URL尾部的/表示目录，没有/表示文件。所以访问/node/时，服务器会自动去该目录下找对应的默认文件或者返回该目录的文件列表。如果访问/node的话，服务器会先去找node文件，找不到的话会将node当成目录重定向到/node/，去该目录下找默认文件或者返回该目录的文件列表。 proxy_pass假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/;}# 代理到URL：http://127.0.0.1:10229/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229; # （相对于第一种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa/;}# 代理到URL：http://127.0.0.1:10229/aaa/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa; # （相对于第三种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/aaatest.html 理解：如果最后有/，就是把URL以location路由切割，把后面的部分放到代理地址的后面，如果没有，就是把路由加上后面的部分放到代理地址的后面。（注意: http://127.0.0.1===http://127.0.0.1/）。 推荐配置代理的写法： 123456789location /proxy/ { proxy_pass http://127.0.0.1/;}location /proxy/ { proxy_pass http://127.0.0.1/aaa/;}# location 的路由最后也加上/# proxy_pass 的最后也加上/# 好处：访问的地址和真实地址在/proxy/之后是完全一样的，便于理解记忆 Node 全局可跨域123456789app.all('*', (req, res, next) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header('Access-Control-Allow-Origin', '*'); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS'); next();}); 指定接口可跨域12345678app.get('/node', (req, res) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header('Access-Control-Allow-Origin', '*'); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS');}); 注：因为Node的路由是由上到下匹配的，有符合的默认就不继续向下匹配了 指定全局可跨域时，一定要先写 app.all 在 app.all 中，一定要加next(), 来让路由继续向下匹配 浏览器插件在chrome网上商店中搜索 Allow CORS: Access-Control-Allow-Origin 插件安装，在需要的时候运行即可。 利用一些不受同源策略影响的标签JSONPJSONP是服务器与客户端跨源通信的一种方法。最大特点就是简单适用，老式浏览器全部支持，服务器不用做任何改造。 理论基础：Web页面上调用js文件时是不受否跨域的影响（不仅如此，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）。 因为JSONP是利用script标签的特性来实现跨域的，所以不支持post请求。 基本思想：在远程服务器上设法把数据装进 js 格式的文件里，供客户端调用和进一步处理。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314151617function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script);}window.onload = function () { // 这里使用一个文本来模拟jsonp服务端返回的最终数据格式 // 文本内容：jsonpExe({\"data\":\"我是jsonp的数据\"}); addScriptTag('http://localhost:1000/jsonp.txt?callback=jsonpExe');}function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 上面代码通过动态添加&lt;script&gt;元素，向服务器localhost:1000发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 1jsonpExe({\"data\":\"我是jsonp的数据\"}); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 或者使用AJAX调用，示例如下： 12345678910111213141516function getJSONPData() { $.ajax({ type: \"get\", url: 'http://localhost:1000/jsonp.txt', dataType: 'jsonp', // 一定要使用 jsonp 类型 success: function(data) { console.log(data); }, error: function(err) {} });}function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 表单提交数据不受同源策略的影响 表单提交:123456789101112131415&lt;!-- 成功 --&gt;&lt;form action=\"http://localhost:10229/setUserInfo\" method=\"post\"&gt; &lt;p&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"user\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" name=\"\" value=\"提交1\"&gt; &lt;input type=\"reset\" name=\"\" value=\"重置1\"&gt; &lt;/p&gt;&lt;/form&gt; ajax请求：12345678910111213// err 跨域$.ajax({ type: \"post\", url: 'http://localhost:10229/setUserInfo', data: { user: 'suyp' }, success: function(data) { console.log(data); $('.txt-erea').text(data); }, error: function(err) {}}); 发散一下思维：虽然form标签只能发送数据，但是没有跨域问题，所以在只需要发送消息的时候也可以使用form来进行单方面通信。Canvas中的跨域问题受影响的方法如下： getImageData()：返回一个ImageData对象，用来描述canvas区域隐含的像素数据 toBlob()：创造Blob对象，用以展示canvas上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 image/png，分辨率为96dpi。 toDataURL() ：返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。 下面以toDataURL() 为例。 在使用Canvas绘制不同域的图片然后转为Base64时，会有跨域问题。但是，不影响Canvas绘制展示图片。 1234567891011121314151617&lt;body&gt; &lt;canvas id=\"myCanvas\" width=\"1920\" height=\"1080\" style=\"border: 2px solid grey\"&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var canvas = document.getElementById(\"myCanvas\") var context = canvas.getContext(\"2d\") var img = new Image() // img.src = './img/思路logo紫.png'; // 同源图片 img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片 //图片加载完后，将其显示在canvas中 img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png')); }&lt;/script&gt; 报错： 解决方式： 设置图片的crossOrigin = 'anonymous',来让toDataURL方法不因跨域报错 设置图片可跨域二者缺一不可。1234567891011121314151617&lt;body&gt;&lt;canvas id=\"myCanvas\" width=\"1920\" height=\"1080\" style=\"border: 2px solid grey\"&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;var canvas = document.getElementById(\"myCanvas\")var context = canvas.getContext(\"2d\")var img = new Image()img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片img.crossOrigin = 'anonymous';//图片加载完后，将其显示在canvas中img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png'));}&lt;/script&gt; 不允许IFrame被嵌入在响应头中有这么一个配置项 X-Frame-Options来标识一个页面是否可以被其他页面嵌入。可选值： deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin：表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri：表示该页面可以在指定来源的 frame 中展示。（uri为指定源的地址） 配置： Tomcat 在 Tomcat根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314151617 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;sameorigin&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 12345678910111213141516171819202122 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;allow-from&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 当指定部分域可展示时，使用下面代码配置指定域 --&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingUri&lt;/param-name&gt; &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 注：目前测试指定域可嵌入无效，错误如下： 1testIframe.html:1 Invalid 'X-Frame-Options' header encountered when loading 'http://localhost:8090/CORS/testIframe.html': 'ALLOW-FROM http://127.0.0.1:10229' is not a recognized directive. The header will be ignored. Nginx配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:add_header X-Frame-Options sameorigin always;add_header X-Frame-Options deny always;add_header X-Frame-Options allow-from 'http://127.0.0.1,http://127.0.0.2' always;小结：跨域网络访问推荐做法： 在能随意操作文件的情况优先把资源分类放到一起，这样既不会有跨域请求问题，也方便管理。 不行的话，使用Nginx代理。 跨域数据存储访问（Cross-origin data storage access）使用域名document.domain 属性中存入的是主机信息，并且可以设置为当前域或者当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。另外，任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null。因此 company.com:8080 不能仅通过设置 document.domain = “company.com” 来与company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。 由于以上的情况，我们可以在多个只有二级域名不同的网页进行以下操作。 注： 域名 域名分类 CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = 'example.com'; 现在，A网页通过脚本设置一个 Cookie。 1document.cookie = \"test1=hello\"; B网页就可以读到这个 Cookie。 1var allCookie = document.cookie; 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，这样二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 DOM如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 document.domain属性，就可以规避同源策略，拿到DOM。 父页面： 1234window.onload = function() { document.domain = 'suyp.com'; document.cookie = 'username=suyp';} 子页面： 1234567891011121314151617181920window.onload = function() { document.domain = 'suyp.com'}// 这里请求时，会带上父页面的cookie: document.cookie = 'username=suyp';function getData() { $.ajax({ type: \"get\", url: 'http://localhost:10229/node', // 默认情况下，标准的跨域请求是不会发送cookie的 xhrFields: { withCredentials: true }, success: function(data) { console.log(data); // $('.txt-erea').text(data); }, error: function(err) {} });} Node服务端： 123456789101112131415161718192021222324252627// 在开启服务的代码基础上新加如下代码const express = require('express');const app = express();const cookieParser = require('cookie-parser');app.use(cookieParser());app.get('/node', (req, res) =&gt; { // 使用cookie时不能设置域为 * res.header('Access-Control-Allow-Origin', req.headers.origin); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS'); // 要设置允许客户端携带验证信息 res.header('Access-Control-Allow-Credentials', true); console.log('cookie信息'); console.log(req.cookies); res.end('');});/** * 开启监听 */app.listen(port, function(){ console.log('ok')}); 注： 同源ajax请求是可以自动携带cookie的 而非同源需要客户端和服务端都做处理： 客户端需要对xhr对象设置withCredentials:true 服务端需要设置响应头 access-control-allow-credentials:true 同时必须指明 access-control-allow-origin 为服务方的origin， 不能为* 新增属性：Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。可选值： StrictStrict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 LaxLax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 NoneNone相当于忽略该属性。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 相关东西，后面补充。 小结：跨域数据存储访问推荐做法： 把文件放在一起或者使用Nginx代理到一起 （推荐） 如果使用的域名可以考虑设置document.domain属性 完全不同源，可以考虑通过跨域通信的方式传递相关参数 跨域脚本API访问（Cross-origin script API access）如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 12document.getElementById(\"myIFrame\").contentWindow.document// Uncaught DOMException: Blocked a frame with origin \"http://127.0.0.1:5500\" from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。 12window.parent.document.body// Uncaught DOMException: Blocked a frame with origin \"http://localhost:1000\" from accessing a cross-origin frame. 对于完全不同源的网站，目前有四种方法，可以解决跨域窗口的通信问题。 片段标识符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） WebSocket 片段标识符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。也可以叫做锚点, 用作页面定位. 父窗口可以把信息，写入子窗口的片段标识符。 12var srcStr = document.getElementsByClassName(\"iframe\")[0].src.split('#')[0] + '#' + encodeURI(value);$('.iframe').attr('src', srcStr); 子窗口通过监听hashchange事件得到通知。 123456window.onhashchange = checkMessage;function checkMessage() { var message = window.location.hash; // ...} 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href= target + \"#\" + hash; 注意：如果修改后的hash值和原来的一样，不会进片段标识符改变的监听 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 1window.name = '{\"name\": \"lisi\"}'; 接着，子窗口跳回一个与主窗口同域的网址。 12// 把子页面的window.location 设置为域和父页面同源的window.location = 'http://127.0.0.1:5500/windowName/testWN.html'; 然后，主窗口就可以读取子窗口的window.name了。 1var data = document.getElementById('myFrame').contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；代码实现： 123456789101112131415161718var state = 0;iframe = document.createElement('iframe'), loadfn = function() { if (state === 1) { var data = iframe.contentWindow.name; // 读取数据 alert(data); // 你好，我是子页面的window.name， 携带了一些数据 } else if (state === 0) { state = 1; iframe.contentWindow.location = \"http://127.0.0.1:10229/page/windowName/null.html\"; // 设置的代理文件 } }; iframe.src = 'http://localhost:1000/windowname-nginx.html'; if (iframe.attachEvent) { iframe.attachEvent('onload', loadfn); } else { iframe.onload = loadfn; } document.body.appendChild(iframe); window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个方法 window.postMessage，允许跨窗口通信，不论这两个窗口是否同源，只要你能获取到目标对象的window对象。 举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 12var popup = window.open('http://aaa.com', 'title');popup.postMessage('Hello World!', 'http://aaa.com'); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送. 子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage('Nice to see you', 'http://bbb.com'); 注：window.opener 属性是一个可读可写的属性，可返回对创建该窗口的 Window 对象的引用。 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener('message', function(e) { console.log(e.data);},false); 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener('message', receiveMessage);function receiveMessage(event) { event.source.postMessage('Nice to see you!', '*');} event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) { if (event.origin !== 'http://bbb.com') return; if (event.data === 'Hello World') { event.source.postMessage('Hello', event.origin); } else { console.log(event.data); }} message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 12345window.addEventListener('message', receiveMessage);function receiveMessage(event) { event.source.postMessage('Nice to see you!', '*');}` event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) { if (event.origin !== 'http://bbb.com') return; if (event.data === 'Hello World') { event.source.postMessage('Hello', event.origin); } else { console.log(event.data); }} 通过window.postMessage，读写其他窗口的 LocalStorage 或者 SessionStorage也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567window.onmessage = function(e) { if (e.origin !== 'http://bbb.com') { return; } var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));}; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 123var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = { name: 'Jack' };win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com'); 加强版的子窗口接收消息的代码如下。 1234567891011121314151617window.onmessage = function(e) { if (e.origin !== 'http://bbb.com') return; var payload = JSON.parse(e.data); switch (payload.method) { case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break; }}; 加强版的父窗口发送消息代码如下。 1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = { name: 'Jack' };// 存入对象win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify({key: 'storage', method: \"get\"}), \"*\");window.onmessage = function(e) { if (e.origin != 'http://aaa.com') return; // \"Jack\" console.log(JSON.parse(e.data).name);}; SessionStorage同理。 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 示例： Node服务端:123456789101112131415161718192021222324252627282930313233const WebSocket = require('ws');// websocket服务的端口const wsport = 3006;var wss = new WebSocket.Server({ port: wsport, path: '/ws'});let webSocketServer = wss.on('connection', function connection(ws) { console.log('ws连接') ws.isAlive = true; ws.on('pong', heartbeat); ws.on('message', function incoming(message) { message = JSON.parse(message); sendAllMessage(webSocketServer, message) });});// 广播消息function sendAllMessage (server, message) { server.clients.forEach(ws=&gt; { ws.send(JSON.stringify(message)); });}// 定时每30s发送ping监测连接是否中断const interval = setInterval(function ping() { wss.clients.forEach(function each(ws) { if (ws.isAlive === false) return ws.terminate(); ws.isAlive = false; ws.ping(); });}, 30000); 页面1：12345678910111213141516171819202122232425var ws = new WebSocket('ws://localhost:3006/ws', 'suyp');ws.onopen = function(param) { console.log('WebSocket连接成功！'); ws.onmessage = function(param) { console.log('这是WebSocket接收的消息 --- ' + param.data); // 接收消息这里推荐写try catch 来捕捉错误，因为消息有可能不是JSON格式 try { var message = JSON.parse(param.data); } catch (e) { console.log(e); } if (message) { switch (message.key) { case 'closeInfoWindow': console.log('弹窗已关闭'); break; default: break; } } } ws.onclose = function() { console.log('ws关闭了'); }} 页面2123456789// 向父页面发送消息,来关闭弹窗function closeInfowWindow2() { if (ws) { ws.send(JSON.stringify({ key: 'closeInfoWindow', msg: '' })) }} 小结跨域脚本API访问推荐做法： Nginx代理到一起 （最好） 使用postMessaget通信 （挺好） 参考资料 什么是JSONP — HansExploration JSONP — 百度百科 浏览器同源策略及其规避方法 — 阮一峰 WebSocket 教程 — 阮一峰 X-Frame-Options — MDN SameSite — MDN","link":"/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"},{"title":"CSS编码规范","text":"1、文件命名 采用 HTML 命名规则。 2、选择器 尽量少用通用选择器 *。 禁止使用 ID 选择器编写样式。 尽可能避免使用属性选择器（例如，[class^=”…”]）。属性选择器相较其他选择器对浏览器的性能消耗是巨大的。 属性选择器必须使用双引号。 3、属性的顺序 顺序：定位 &gt; 盒模型 &gt; 文字 &gt; 其他内部属性 &gt; 其他 CSS3 属性。 1234567891011121314定位属性z-index，position，float，top，right，bottom，left盒模型属性width，height，padding，margin，border文字属性font-\\*，line-height，text-align，text-decoration....其他内部属性overflow，opacity，cursor....其他 css3 属性animation，transition，transform.... 4、代码编写规范 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）。 每个属性声明末尾都要加分号。 左括号与类名之间一个空格，冒号与属性值之间一个空格。 逗号分隔的取值，逗号之后一个空格。 每个选择器单独占一行。 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0。 属性值十六进制数值能用简写的尽量用简写。 不要为 0 指明单位。 可简写的属性设置多值时，尽量使用简写语法。 可简写的属性设置单值时，尽量不使用简写语法。 尽量不要在 CSS 中使用!important。 url()中的路径不添加引号。 避免使用标签选择器编写样式。 123456789.fs,.fc { display: block; width: 50px; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc; color: rgba(255,255,255,.5); background: #fff; margin: 0;} 5、浏览器私有前缀的写法 CSS3 浏览器私有前缀在前，标准前缀在后。 1234567.fs { -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;} 6、注释 注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行。 12/* Comment Text */.fs{} 不同人编写的 css 应该加上对应的注释，注明页面说明、作者、日期等信息。 1234567891011/** * @description 说明 * @author 作者 * 修改者（多个人） * @date 2015-10-10 最后的修改时间 */ 7、重置标签的默认样式 因为不同浏览器对有些标签的默认值是不同的，如果不对 css 初始化往往会出现浏览器之间的页面显示差异，为了让各个浏览器的 CSS 样式有一个统一的基准，使 HTML 元素样式在跨浏览器时有一致性的效果，所以需要重置 css 的默认样式。（以下代码，在使用 fbi 创建项目时会自动生成） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 清除默认样式 */* { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;}html,body { padding: 0; margin: 0; font-family: 'Microsoft yahei';}ul,ol,li,span,p,h1,h2,h3,h4,h5,h6,a,dl,dt,dd,input { padding: 0; margin: 0; list-style: none; text-decoration: none; font-weight: normal; font-style: normal; font-family: 'Microsoft yahei'; font-size: 14px;}a { cursor: pointer;}img { vertical-align: middle; border: 0;}","link":"/2020/08/28/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"HTML编码规范","text":"1、文件命名 文件名不得包含空格和特殊字符。 文件名统一使用小写字母(为了醒目，某些说明文件的文件名，可以使用大写字母，比如 README、LICENSE )。 文件名包含多个单词时，单词之间以中划线 ( - ) 分隔。 入口文件使用 index 命名（比如 index.html、index.asp、index.jsp）。 命名的原则是语义化，方便理解，见名知意。 外部插件建议放在 modules 目录里，组件建议放在 components 目录里，不要全都放到 js 文件夹中。 使用统一的自动化工具构建页面结构。 123npm install -g tfbifbi init 项目名称 2、DOCTYPE 声明 为了确保在每个浏览器中拥有一致的展现效果，HTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明。 1&lt;!DOCTYPE html&gt; 3、页面语言 LANG 强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。 1&lt;html lang=\"zh-cmn-Hans\"&gt; 4、文档编码 为了防止文档在不同浏览器下出现乱码的问题，统一只用 utf-8 编码。 1&lt;meta charset=\"UTF-8\"&gt; 5、命名风格 HTML 标签名、ID 名、类名、标签属性和大部分属性值统一用小写，用中划线链接。 ID 名是唯一的，一般写在最外层元素上，禁止使用 ID 写 css 样式。 对于引号的运用，必须使用双引号，禁止使用单引号。 避免过度任意的简写，.btn 代表 button，但是 .b 不能表达任何意思。 使用 .js-* 来标识行为，并且不要将这些 class 写到 CSS 文件中(加具体的事件名)。 嵌套标签建议基于最近的父 class 或规定关键字作为新 class 的前缀。 123&lt;div class=\"demo\"&gt; &lt;div class=\"demo-info\"&gt;&lt;/div&gt;&lt;/div&gt; 6、标签 每个标签都有自己的定义，HTML 中必须使用语义化标签，禁止一直使用一类标签。 HTML 中使用双闭合标签时标签必须闭合，使用单闭合标签时尾部不加斜杠。 行内元素不要嵌套块级元素。p 标签中是不能嵌套块级元素的，浏览器会解析为两个独立的标签。 使用 img 标签时，建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。 7、关于 JS 和 CSS 根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 text/css 和 text/javascript 分别是它们的默认值。这一点在老旧浏览器上也是支持的。 引入 JS 时 script 标签如无特殊情况统一放在 body 结束标签的前面，引入 CSS 时 link 标签统一放在 head 结束标签的前面，因为浏览器生成 Dom 树的时候是一行一行读 HTML 代码的，link 标签放在最后页面会出现短暂无样式的效果，script 标签放在最后面就不会影响前面的页面的渲染。 原则上禁止在 HTML 中编写 JS 代码，禁止在 HTML 中编写内联样式。 8、注释 HTML 中必要时增加注释代码。 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。 123&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 9、代码格式化 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）（浏览器的配置文件）。 嵌套元素必须缩进一次（两个空格）。 元素嵌套时，每个块状元素独立一行，内联元素可选。","link":"/2020/08/28/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"Vue3.js模板项目创建","text":"基础环境 Vue CLI 版本为 4.5.6 Node.js 版本为 14.9.0 （官方建议是 10 以上版本，最低为 8.9） yarn 版本为 1.22.5 通过以下命令行查询对应版本号： 12345vue --version // @vue/cli 4.5.6node --v // v14.9.0yarn -v // 1.22.5 如发现版本不满足要求，可以分别通过： 运行以下命令行，更新 Vue CLI 至最新版本 1npm i -g @vue/cli 前往 Node.js 下载最新版本的程序，并安装。 运行以下命令行，更新 yarn 至最新版本 1npm i -g yarn 项目创建Vue 默认会通过以前选择过的包管理工具 yarn 或 NPM 来安装依赖。想全局修改的话，可在命令行中运行: 1vue config --set packageManager yarn // 或 npm 推荐 yarn 也可在创建项目时动态指定当前项目的包管理工具： 1vue create vue3-starter -m yarn 勾选以下几项(单击图片可看大图): 依次选择如下内容： 最后会问是否要保存当前这个配置，按自己的意愿选择和命名。 成功后，运行如下命令行： 12cd vue3-starteryarn serve 在浏览器中打开 http://localhost:8080/ 看到页面就算完成了。 项目改造默认结构1234567891011121314151617181920212223242526├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ └── index.html // HTML模板页├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ └── logo.png│ ├── components // 组件(dumb components，获取props，派发事件)│ │ └── HelloWorld.vue // 示例组件│ ├── router // 路由（统一使用懒加载）│ │ └── index.ts // 组装各路由并导出│ ├── store // 状态管理（可选）│ │ └── index.ts│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── About.vue // 关于│ │ └── Home.vue // 首页│ ├── App.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明└── tsconfig.json // TypeScript配置文件 内容改造文件夹创建在 src 文件夹下创建 hooks、layouts、plugins、services、utils 文件夹（每个文件夹的作用在下方改造后的目录结构中有说明） 在 assets 文件夹下创建 fonts、icons、images、styles 文件夹，删除 logo.png 文件修改和删除修改 public 文件夹下的 index.html12&lt;!-- &lt;html lang=\"en\"&gt; 改为中文，否则安装了翻译插件的浏览器会弹出是否要翻译本页对话框--&gt;&lt;html lang=\"zh\"&gt;&lt;/html&gt; 删除 components 文件夹下HelllWorld.vue 删除 views 文件夹下About.vue 按 kebab-case 命名法，修改所有不符合规范的文件和对应文件中的引用App.vue -&gt; app.vue, Home.vue -&gt; home.vue 依赖添加Normalize.css （初始化样式）1yarn add normalize.css axios（HTTP 请求）1yarn add axios 文件创建在根目录下添加 vue.config.js 文件来扩展 webpack 配置12345678910111213141516171819202122232425/** * 判断是否是生产环境 * @returns {boolean} 是否是生产环境 */function isProd() { return process.env.NODE_ENV === \"production\";}module.exports = { publicPath: isProd() ? \"./\" : \"/\", // 部署到生产环境时，按需修改前项为项目名称 productionSourceMap: false, // 不需要生产环境的 source map，减少构建时间 configureWebpack: (config) =&gt; { if (isProd()) { // 去除 console Object.assign( config.optimization.minimizer[0].options.terserOptions.compress, { // eslint-disable-next-line @typescript-eslint/camelcase drop_console: true, } ); } },}; home.vue1234567891011121314151617181920// home.vue 添加一个通过ref绑定数据的示例&lt;template&gt; &lt;div&gt; {{title}} &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import { ref, defineComponent } from 'vue';export default defineComponent({ name: 'Home', setup() { const titleRef = ref('首页'); return { title: titleRef, }; },});&lt;/script&gt; .eslintrc.js1234567891011121314151617181920// .eslintrc.jsmodule.exports = { root: true, env: { node: true, }, extends: [ \"plugin:vue/vue3-essential\", \"@vue/airbnb\", \"@vue/typescript/recommended\", ], parserOptions: { ecmaVersion: 2020, }, rules: { \"no-console\": \"off\", \"no-debugger\": \"off\", \"prefer-default-export\": \"off\", },}; router.ts123456789101112131415161718// router.ts 删除了about的路由import { createRouter, createWebHashHistory, RouteRecordRaw } from \"vue-router\";import Home from \"../views/home.vue\";const routes: Array&lt;RouteRecordRaw&gt; = [ { path: \"/\", name: \"Home\", component: Home, },];const router = createRouter({ history: createWebHashHistory(), routes,});export default router; app.vue1234567// app.vue&lt;template&gt; &lt;div id=\"nav\"&gt; &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt; main.ts1234567// main.tsimport { createApp } from \"vue\";import App from \"./app.vue\"; // 修改App为appimport router from \"./router\";import store from \"./store\";createApp(App).use(store).use(router).mount(\"#app\"); 改造后的结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ ├── fonts // 字体文件（可选）│ │ │ └── ...│ │ ├── icons // 图标（可选）│ │ │ └── ...│ │ ├── images // 图片（可选）│ │ │ ├── exception // exception（通用异常页面）模块使用到的图片 （待添加）│ │ │ │ └── ...│ │ │ ├── module-a // 此处要用模块命名（可选）│ │ │ │ └── ... // 该模块下使用到的图片│ │ │ └── ... // 通用的图片（小项目就不用分文件夹了）│ │ └── styles // 样式│ │ ├── common.scss // 常用样式（提供通用的）│ │ ├── global.scss // 全局样式│ │ ├── style.scss // 组装各样式并导出最终被 main.js 引入│ │ └── ...│ ├── components // 组件(dumb components，获取props，派发事件)│ │ ├── common // 不同项目中的通用组件（可选）│ │ │ └── ...│ │ ├── module-a // 此处要用模块命名（可选）│ │ │ └── ... // 该模块下的组件│ │ └── ... // 当前项目中的通用组件│ ├── hooks // 钩子│ │ ├── common // 不同项目中的通用hooks│ │ │ └── ...│ │ └── ... // 本项目中通用的hooks│ ├── layouts // 布局（可选）│ │ └── ...│ ├── plugins // vue插件（如：Element，vuetify）│ │ ├── index.ts // 组装各插件并导出│ │ └── ...│ ├── router // 路由（统一使用懒加载）│ │ ├── index.ts // 组装各路由并导出│ │ └── ...│ ├── services // 接口请求│ │ ├── config.ts // 常量│ │ ├── index.ts // 组装各请求并导出│ │ └── ...│ ├── store // 状态管理（可选）│ │ ├── modules // 各模块│ │ │ └── ... // 尽量和views中的模块对应上│ │ ├── actions.ts // 根级别的 action│ │ ├── getters.js // 根级别的 getter│ │ ├── index.ts // 组装模块并导出│ │ ├── mutation-types.ts // mutation事件类型定义│ │ └── mutations.ts // 根级别的 mutation│ ├── utils // 工具类│ │ ├── config.ts // 常量│ │ ├── common.ts // 常用功能（提供通用的）│ │ ├── request.ts // HTTP请求│ │ ├── validator.ts // 表单验证│ │ └── ...│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── exception // 通用异常展示页面 （待添加）│ │ │ ├── NotFound.vue // 404页面│ │ │ └── Unauthorized.vue // 401页面│ │ ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面│ │ │ └── ...│ │ └── ...│ ├── app.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明├── tsconfig.json // TypeScript配置文件└── vue.config.js // 自定义webpack配置","link":"/2020/09/14/Vue3-js%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"title":"优化if-else逻辑判断","text":"前言为什么要优化if else逻辑判断呢？我们应该如何去优化它呢？优化它有什么意义呢？ 在分享之前我们先看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 贷款申请操作的处理function check() { // 是否输入正确用户名 if (this.checkUsername(this.username)) { // 是否输入正确身份证号 if (this.checkIdCard(this.idCard)) { // 请输入正确的电话号码 if (this.checkTel(this.tel)) { // 担保人是本人 if (this.dbr === '担保人是本人') { // 是否存在身份证正面 if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') // 是否存在身份证反面 if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') // 是否存在学历证书 if (document.querySelector('.xlzs img')) { console.log('存在学历证书') if (this.ydxy) { this.tijiaoIsShow = false } } else { Toast('请上传学历证书') this.tijiaoIsShow = true } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else if (this.dbr == '担保人不是本人') { if (this.checkUsername(this.dbrname)) { if (this.checkIdCard(this.dbridCard)) { if (this.checkTel(this.dbrzyzh)) { if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') if (document.querySelector('.xlzs img')) { console.log('存在学历证书') this.tijiaoIsShow = false } else { Toast('请上传学历证书') } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else { Toast('请输入担保人展业证号') } } else { Toast('请输入担保人身份证号') } } else { Toast('请输入担保人姓名') } } else { Toast('请选择担保人是否为本人') } } else { Toast('请输入正确的电话号码') } } else { Toast('请输入正确的身份证号') } } else { Toast('请输入正确的姓名') }} 看完这样一个代码后，相信大家和我的心情是一样的： 因为我们每次维护时要记住好几个逻辑判断分支，才能知道到底什么情况下才能得到那个结果，这种代码的可读性和可维护性自然就比较低了。 箭头式代码。 12345678910// ................... // ................... // ................... // ................... // ................... // ................... // ................... // ................... // ...................// ................... 那我这次分享的目的就是通过优化某种场景下的if else语句，使得优化后的代码看着比较清爽，从而提高代码的可读性和可维护性。 那接下来我就带大家了解一下具体场景下的if else优化方法有哪些，先从简单的场景入手。 单个if语句优化策略需求：当条件为真时打印出日志内容 优化前 12345678let flag = true;if (flag) { log();}function log() { console.log('如果flag值为真的时候打印这段文字');} 优化后 123456let flag = true;flag &amp;&amp; log();function log() { console.log('如果flag值为真的时候打印这段文字');} 好处：代码在一行很清晰，简洁，好读。 单个if else语句优化策略提前return需求：执行登录操作，如果用户名和密码输入框为空，那么我们就提示用户”用户名和密码不能为空”类似信息；如果都不为空，那我们就执行登录的操作。 优化前 12345678let user = 'silu';let password = 'solution';if (user &amp;&amp; password) { // 执行登录操作} else { return '用户名和密码不能为空';} 优化后：排非策略，先排除为false的情形，通过后再执行为true时的业务逻辑 1234567let user = 'silu';let password = 'solution';if(!user || !password) { return '用户名和密码不能为空';}// 执行登录操作 好处：可以干掉else，减少代码分支，提高代码的可维护性和可阅读性。 使用条件三目运算符使用场景：在不影响可读性的情况下，处理if else分支下简短的返回值、单个简短赋值语句、调用单个相应函数时，建议使用三目运算符。 示例一：if else分支下简短返回值 优化前： 1234567function demo(flag) { if (flag) { return 'true'; } else { return 'false'; }} 优化后 123function demo(falg) { return flag ? 'true' : 'false';} 示例二：if else分支下简短赋值 优化前： 12345678function demo(flag) { let val = ''; if (flag) { val = 'true'; } else { val = 'false'; }} 优化后： 123function demo(flag) { let val = flag ? 'true' : 'false';} 示例三：if else分支下调用单个函数 优化前： 1234567function demo(flag) { if (flag) { success(); } else { fail(); }} 优化后 123function demo(flag) { flag ? success() : fail();} 好处：在以上场景中，使用条件三目运算符相比if else来说，语句在一行中书写，代码非常精炼，执行效率更高 。 多个if else嵌套优化策略 需求：后端大哥说了，给你返回的数据里面如果有 userInfo字段，并且userInfo下面有hobby字段并且有值就显示 hobby里面的内容，否则页面 hobby这一块不显示 12345678910let result = { status: 200, msg: 'success', data: { userInfo: { name: 'doudou', hobby: ['吃饭', '睡觉', '打豆豆'] } }} 一般写法：“金字塔一样的if else嵌套” 1234567891011121314151617if (result.data) { if (result.data.userInfo) { if (Array.isArray(result.data.userInfo.hobby)) { if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 } else { return 'hobby字段为空'; } } else { return 'hobby字段不是一个数组'; } } else { return 'userInfo字段不存在'; }} else { return 'data字段不存在';} 但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们写这种代码时都应该尽量避免过多的if else嵌套。下面我就开始分享几个可以减少if else嵌套的方法。 第一种优化 123456if (!result.data) return 'data字段不存在';if (!result.data.userInfo) return 'userInfo字段不存在';if (!Array.isArray(result.data.userInfo.boddy)) return 'hobby字段不是一个数组';if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作} 遵循的一般规则是，当发现无效条件时，提前返回。 好处：对于多层的if嵌套，使用此方法，代码看起来更简洁，可读性高，增强了代码的可维护性。 第二种优化 适合严谨又懒的前端 12345678try { // 有可能出现错误的代码写在这里 if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 }} catch (error) { // 出错后的处理写在这里} 采取的try catch策略 如果try中的代码没有出错，则程序正常运行try中的内容后，不会执行catch中的内容， 如果try中的代码一但出错，程序立即跳入catch中去执行代码，那么try中代码出错后的程序就不再执行了. 第三种优化 使用可选链（optional chaining)：我们都知道如果我们对一个空值进行属性读取的时候，程序会抛出异常。就像上面那个例子，在多级嵌套的对象中取属性值的时候更容易出现这个问题。那么我们为了保证程序的健壮性，就需要确保对象不为空时再读取下一级的值。 1234// 可选链优化if(result ?.data ?.userInfo ?.hobby ?.length) { // 进行业务逻辑操作} 再也不用为了解决容错而写过多重复代码了， 操作符 *?.* 会检查操作符左边的值是否是空值。如果是null 或 undefined，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查。 可选链操作符( ?. )，当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明 。 多个else if分支优化策略需求: 有多个按钮，点击按钮执行相应业务逻辑操作。 按钮点击后根据按钮的不同type分别做两件事，第一、打印出对应日志，第二、跳转到对应的页面。 1234567891011121314151617181920212223242526/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { if (type === '1') { showLog('女装'); jumpTo('womenPage'); } else if (type === '2') { showLog('男装'); jumpTo('menPage'); } else if (type === '3') { showLog('童装'); jumpTo('childPage'); } else if (type === '4') { showLog('美妆'); jumpTo('makeupPage'); } else if (type === '5') { showLog('箱包'); jumpTo('bagPage'); } else { showLog('推荐好物'); jumpTo('recommendPage'); }} 多数新人在工作中常用switch case进行改写。 12345678910111213141516171819202122232425262728293031/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { switch (type) { case '1': showLog('女装'); jumpTo('womenPage'); break; case '2': showLog('男装'); jumpTo('menPage'); break; case '3': showLog('童装'); jumpTo('childPage'); break; case '4': showLog('美妆'); jumpTo('makeupPage'); break; case '5': showLog('箱包'); jumpTo('bagPage'); break; default: showLog('推荐好物'); jumpTo('recommendPage'); }} 注：不要忘记在每个case语句后放一个break，case语句只是指明了想要执行代码的起点，并没有指明终点，如果没有在case语句中添加break语句，没有明确的中断流程，在每次条件判断后都会执行下次判断条件，可能会造成逻辑混乱。 使用 switch case 后的语句的确比if else看着清晰易读了些，但是当需求增多后代码看起来还是那么的臃肿，似乎并没有从根本上解决问题，和if else的写法对比也不是很明显的提高。 那接下来我们就换种方法,借助对象的{key，value}结构优化 1234567891011121314151617181920const actions = { '1': ['女装', 'womenPage'], '2': ['男装', 'menPage'], '3': ['童装', 'childPage'], '4': ['美妆', 'makeupPage'], '5': ['箱包', 'bagPage'], 'default': ['推荐好物', 'recommendPage']}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions[type] || actions['default']; // 打印日志 showLog(action[0]); // 跳转页面 jumpTo(action[1]);} 借助对象结构的这种写法，把判断条件作为对象的属性名，处理逻辑要传入的参数作为对象的属性值，在执行按钮点击事件时通过查询对象中的键，获取到键对应的值，然后执行对应的处理逻辑。这种写法非常的适合一元条件判断的情况。 问：那除了借助对象结构来实现优化，还有其它方法吗？ 答：我们还可以借助ES6中的 Map 数据结构来优化 ； Map 对象保存键值对。任何类型值(对象或者原始值) 都可以作为一个键或一个值。 123456789101112131415161718const actions = new Map([ ['1', ['女装', 'womenPage']], ['2', ['男装', 'menPage']], ['3', ['童装', 'childPage']], ['4', ['美妆', 'makeupPage']], ['5', ['箱包', 'bagPage']], ['default', ['推荐好物', 'recommendPage']]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions.get(type) || actions.get('default'); showLog(action[0]); jumpTo(action[1]);} 上面用到了es6里的Map对象。Map对象和Object对象的区别: 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。 如果我们把问题再升级一下，在点击按钮时不仅要判断type，还要判断用户的身份——男用户or女用户。 123456789101112131415161718192021222324252627282930313233343536/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { if (sex === 'women') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } } else if (sex === 'men') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } }} 从上方示例代码中可以看出，如果判断条件变为二元条件判断时，if else的数量就增加到一元判断条件的二倍，代码看着更臃肿了。那么对于二元的条件判断我们应该怎么去优化它们呢？ 1234567891011121314151617181920212223const actions = new Map([ ['women_1', () =&gt; {/* do something */}], ['women_2', () =&gt; {/* do something */}], ['women_3', () =&gt; {/* do something */}], ['women_4', () =&gt; {/* do something */}], ['women_5', () =&gt; {/* do something */}], ['men_1', () =&gt; {/* do something */}], ['men_2', () =&gt; {/* do something */}], ['men_3', () =&gt; {/* do something */}], ['men_4', () =&gt; {/* do something */}], ['men_5', () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { let action = actions.get(`$(sex)_$(type)`) || actions.get('default'); action.call(this);} 上面这种处理思想是，把条件判断拼接成字符串作为键，每个分支下的处理逻辑作为值，在使用时传入参数使用Map查询，这种方法非常适合于二元或多元条件判断。 如果你不喜欢把查询条件拼接为字符串使用，这还有一种方法，把查询条件作为对象，借助Map数据结构实现。 1234567891011121314151617181920212223242526272829303132333435const actions = new Map([ [{ sex: 'women', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '5' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '5' }, () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用filter查询 let action = [...actions].filter(([key, value])=&gt;(key.sex === sex &amp;&amp; key.type === type)); action.forEach(([key, value]) =&gt; value.call(this));}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用find查询 let action = [...actions].find(([key, value]) =&gt; (key.sex === sex &amp;&amp; key.type === type)); action[1].call(this);} 上方在执行按钮点击事件时，根据条件查询相应执行逻辑时，提供了filter和find两种查询方式，个人觉得使用filter更为正式，使用find更容易阅读，当然你也可以使用其它方法啦~ 从这里我们就看出了使用Map相对于Object存在的优势了，Map数据结构可以以任意类型的值作为key。 假如在women情况下，type为1,2,3,4时的处理逻辑都一样该怎么写呢？ 12345678const actions = new Map([ [{ sex: 'women', type: '1'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '2'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '3'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '4'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '5'}, ()=&gt;{ /* 执行B逻辑 */}], // ……]); 这样写的话Map里面就会显得比较臃肿，具体的执行逻辑处理过程都放在了Map里面。好点的写法可以是这样子。 12345678910const logicA = ()=&gt;{ /* 执行A逻辑 */ };const logicB = ()=&gt;{ /* 执行B逻辑 */ };const actions = new Map([ [{ sex: 'women', type: '1'}, logicA], [{ sex: 'women', type: '2'}, logicA], [{ sex: 'women', type: '3'}, logicA], [{ sex: 'women', type: '4'}, logicA], [{ sex: 'women', type: '5'}, logicB], // ……]); 上面的写法虽然Map中结构清晰了，日常需求的话可以这么写也是没什么问题的。但是，如果以后增加需求，women条件下type为6、7、8、10、11……的逻辑处理都是一样的。那么我们还要像上方那样的写法在Map中一一增加同样的执行逻辑吗？ 显然，这样的话会变得比较繁琐，那么我们还有其它办法来应对这种情况吗？ 123456789function actions() { const logicA = ()=&gt;{ /* 执行A逻辑 */ }; const logicB = ()=&gt;{ /* 执行B逻辑 */ }; const action = new Map([ [/^women_[1-4]$/, logicA], [/^women_5$/, logicB], // …… ]);} 利用正则进行判断条件匹配后，代码又清爽了许多。并且这里使用Map后的优势就更加的明显了，符合正则的条件的公共逻辑都会执行。 总结下这部分的内容： 一元条件判断：存到Object中。 一元条件判断：存到Map中。 二元或多元判断：将判断条件拼接成字符串存到Object中。 二元或多元判断：将判断条件拼接成字符串存到Map中。 多元判断时：将判断条件写成Object存到Map中。 多元判断时：将判断条件写成正则存到Map中。 使用数组新特性优化逻辑判断在工作中，巧妙的使用ES6中提供的数组新特性，也可以达到轻松优化逻辑判断的效果。 使用includes优化代码逻辑需求：判断animal是否属于cute类型。 当我们遇到多条件判断时，本能的写下以下代码。 123456const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (animal === 'dog' || animal === 'cat' || animal === 'bird' || animal === 'panda') { console.log('可爱的小动物'); }} 但是当cuteAnimal的种类多达十几种或者是更多的时候，我们就只能通过这种||的形式去维护吗？ 这时候我们可以试着使用includes方法 1234567const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (cuteAnimal.includes(animal)) { console.log('可爱的小动物'); }} 这个时候后期维护的话，增加动物类型时只需要在cuteAnimal数组中增加，当类型数量多时，代码看起来还是很简洁，不像上面使用很多||那么杂乱 使用every优化代码逻辑需求：判断animals数组中的动物是否都属于cute类型 every：判断数组的每一项是否都满足条件，都满足条件返回true，否则返回false 12345678910111213141516171819202122232425const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function type() { let isAllCute = true; // 判断条件：animals中的动物是否都是cute类型 for (let animal of animals) { if (!isAllCute) break; isAllRed = (animal.type === 'cute'); } console.log(isAllCute); // false} 使用every方法，更容易处理上面的判断逻辑 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否都是cute类型 const isAllCute = animals.every(animal =&gt; animal.type === 'cute'); console.log(isAllCute); // false} 使用some方法优化代码逻辑需求：判断animals中的动物是否存在有tall类型的。 some()是对数组中每一项运行给定函数，如果有一项符合条件，则返回true，都不符合条件返回false。 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否含有tall类型 const isHasTall = animals.some(animal =&gt; animal.type === 'tall'); console.log(isHasTall); // true} 默认值优化优化前 12345function request(options) { let method = options.method ? options.method : 'GET'; let data = options.data ? options.data : {} //...} 优化后 12345function request(options) { let method = options.method || 'GET'; let data = options.data || {}; //...} 基于ES6优化后 123456// 解析解构和默认参数搭配使用function request({ method, data } = { method: 'GET', data: {}}){ //... console.log(method); // GET console.log(data); // {}} 使用策略模式优化分支逻辑需求：咱马上要过国庆节啦，得打折清仓呀，有的商品5折，有的7折，有的9折~ 优化前 123456789101112131415161718192021222324252627function percent50(price) { // 五折的算法}function percent70(price) { // 七折的算法}function percent90(price) { // 九折的算法}function calculatePrice(price) { if (五折的商品) { return percent50(price); } if (七折的商品) { return percent50(price); } if (九折的商品) { return percent50(price); }}calculatePrice(price); 写到这里需求又来了，那以后的中秋节、元旦、情人节、元宵节……都要促销呀！再来个满300减50，满500减80，vip用户满500-150上不封顶！对于这种越来越多的需求，还要深入函数内部一一增加if分支吗？ 以上写法的缺点： calculatePrice函数比较庞大，包含了很多if else语句 如果再增加更多相似需求，必须要深入到calculatePrice函数内部实现，违反了开放封闭原则。 使用策略模式优化策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式是一种对象行为型模式。 这里的算法其实就是业务逻辑，为了更形象，干脆将其理解为一个函数。其实这个定义的基本意思就是说，根据策略选择要执行的函数，而每一个策略都会有一个标识名，可以称为key。而策略名对应的函数，可以称为value，其实就是使用key寻找value，然后执行vlaue的过程。也就是说，根据条件去执行相应的业务逻辑，从这层意思上理解，就是if else要干的事。 使用策略模式优化后： 使用思路：定义一个对象封装不同的行为，提供选择接口，在不同条件下调用相应的行为。 12345678910111213141516171819202122232425262728293031323334// 策略类let strategy = { // 5折 percent50(price) { return price * 0.5; }, // 7折 percent70(price) { return price * 0.7; }, // 9折 percent90(price) { return price * 0.9; }, // 满300-50 fullReduce50(price) { // 执行满300-50的业务逻辑 }, // 满300-80 fullReduce80(price) { // 执行满300-80的业务逻辑 }, // vip用户五折 vip50(price) { // vip用户五折的业务逻辑 }};// 调用策略类中的方法// 环境类function calculatePrice(strategyName, price) { return strategy[strategyName] &amp;&amp; strategy[strategyName](price);};console.log(calculatePrice('percent50', 100)); // 50 使用策略类优化后，后期再增加需求时，我们就不需要再深入到calculatePrice函数内部增加分支了，只需要在strategy策略类中增加相应的算法就可以啦！这样的代码是不是在后期更好维护呢！！！ 上面例子中： 策略类 是指strategy对象，保存了所有的策略名对应的方法。 环境类 是用接收策略名和其它参数，然后调用对应的策略方法。 好处： 有效的避免了多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法独立封装在strategy中，使得这些算法易于切换、易于理解、易于扩展。 总结 更少的嵌套，尽早 return 。 倾向于使用对象或使用map结构来优化if else，而不是 Switch 语句 。 多重判断时使用 Array.includes 。 对 所有/部分 判断使用 Array.every &amp; Array.some 。 使用默认参数和解构 。 当一个项目中需要大量算法，大量匹配模式时可以考虑使用策略模式。 感想 让我们感到快乐和幸福的方法，无非是全身心的投入到我们稍微努力一下就能完成的事情中去。是这样的，太难的事情我们很难去完成最终丧失信心，而简单的事情又不能勾起我们的兴趣，只有像这种看似比较难，但是稍微努力就能完成的事情，才能给我们带来很大的快乐。","link":"/2020/09/30/%E4%BC%98%E5%8C%96if-else%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/"}],"tags":[{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Vue.js2","slug":"Vue-js2","link":"/tags/Vue-js2/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"ESLint","slug":"ESLint","link":"/tags/ESLint/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Browserslist","slug":"Browserslist","link":"/tags/Browserslist/"},{"name":"概念","slug":"概念","link":"/tags/%E6%A6%82%E5%BF%B5/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Module","slug":"Module","link":"/tags/Module/"},{"name":"Rap2","slug":"Rap2","link":"/tags/Rap2/"},{"name":"Mock","slug":"Mock","link":"/tags/Mock/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Vue.js3","slug":"Vue-js3","link":"/tags/Vue-js3/"},{"name":"if-else","slug":"if-else","link":"/tags/if-else/"}],"categories":[{"name":"协议","slug":"协议","link":"/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"周边","slug":"周边","link":"/categories/%E5%91%A8%E8%BE%B9/"},{"name":"JS框架","slug":"JS框架","link":"/categories/JS%E6%A1%86%E6%9E%B6/"},{"name":"持续集成","slug":"持续集成","link":"/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"HTTP","slug":"协议/HTTP","link":"/categories/%E5%8D%8F%E8%AE%AE/HTTP/"},{"name":"概念","slug":"概念","link":"/categories/%E6%A6%82%E5%BF%B5/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"博客","slug":"周边/博客","link":"/categories/%E5%91%A8%E8%BE%B9/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"开发周边","slug":"开发周边","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/"},{"name":"Vue.js2","slug":"JS框架/Vue-js2","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js2/"},{"name":"跨平台","slug":"跨平台","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"项目搭建","slug":"持续集成/项目搭建","link":"/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"Vue.js3","slug":"JS框架/Vue-js3","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js3/"},{"name":"基础","slug":"概念/基础","link":"/categories/%E6%A6%82%E5%BF%B5/%E5%9F%BA%E7%A1%80/"},{"name":"编码规范","slug":"TypeScript/编码规范","link":"/categories/TypeScript/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"模块化(Module)","slug":"JavaScript/模块化-Module","link":"/categories/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96-Module/"},{"name":"Rap2","slug":"开发周边/Rap2","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/Rap2/"},{"name":"PWA","slug":"跨平台/PWA","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/PWA/"},{"name":"新特性","slug":"JavaScript/新特性","link":"/categories/JavaScript/%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"跨域","slug":"安全/跨域","link":"/categories/%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/"},{"name":"编码规范","slug":"CSS/编码规范","link":"/categories/CSS/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"编码规范","slug":"HTML/编码规范","link":"/categories/HTML/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"优化","slug":"优化","link":"/categories/%E4%BC%98%E5%8C%96/"},{"name":"优化if-else","slug":"优化/优化if-else","link":"/categories/%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96if-else/"}]}